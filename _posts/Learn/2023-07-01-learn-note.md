---
title: "Learning Note"
description: 记录的随笔 
date: 2023-07-01 10:00:00 +0800
categories: [Learn, Note]
tags: [Learn, Note]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

## 传递信息方式
>**全局变量**：例如通过flag标志位进行信息传递  
>**信号量，互斥锁**：可以用于资源访问，也可以用于事件等待，关键在于创建时分配的资源数，若为0，则为等待事件，若为1，在申请资源不释放，但是设置超时时间不为0，则可以实现定时任务  


 
## 技巧：调试宏
建议定义一个STATIC宏，在调试阶段，将STATIC定义为static，版本发布时，改为空，以便于后续的 打热补丁等操作
```c
#ifdef _DEBUG
#define STATIC static
#else
#define STATIC
```

## IAP
`IAP`，即`In Application Programming`，IAP是用户自己的程序在运行过程中（BOOT）对User Flash的部分区域进行烧写。  


## 字符编码介绍   
- [# 字符编码](https://blog.csdn.net/xiaxiaorui2003/article/details/52488711)  

## CRC 循环冗余校验  
检错能力极强，开销小，易于用编码器及检测电路实现。从其检错能力来看，它所不能发现的错误的几率仅为0.0047%以下。从性能上和开销上考虑，均远远优于奇偶校验及算术和校验等方式。因而，在数据存储和数据通讯领域，CRC无处不在：著名的通讯协议X.25的FCS（帧检错序列）采用的是CRC-CCITT，ARJ、LHA等压缩工具软件采用的是CRC32，磁盘驱动器的读写采用了CRC16，通用的图像存储格式GIF、TIFF等也都用CRC作为检错手段。  

## keyboard 宏快捷键  

|  | SI | VSC |
|--|--|--|
| 声明 | M1 | M1 |
| 定义 | M2 | M2 |
| 调用 | M3 |  |
| 引用-覆盖 | M4 |  |
| 引用-询问 | M5 |  |
| 所有引用 |  | M6 |
| 返回 | M11 | M11 |
| 前进 | M12 | M12 |

## 露点/露点温度
露点/露点温度Td，在空气中水汽含量不变， 保持气压一定的情况下， 使空气冷却达到饱和时的温度称露点温度，简称露点，单位用℃或℉表示。  
形象地说，就是空气中的水蒸气变为露珠时候的温度叫露点温度。  
在一定的空气压力下，逐渐降低空气的温度，当空气中所含水蒸气达到饱和状态，开始凝结形成水滴时的温度叫做该空气在空气压力下的露点温度。即当温度降至露点温度以下，湿空气中便有水滴析出。  
如果露点越低，表示空气中的水分含量越少。  
露点温度越小于周围环境的温度，结露的可能性就越小，也就意味着空气越干燥。  
除湿目的，降低露点温度。  

## 芯片引脚1 辨认方法
- 当芯片有缺口时，缺口向上，缺口左面为第一脚，沿逆时针方向递增
- 当芯片有圆点时，将小圆点置于左上方，圆点左面为第一脚，沿逆时针方向递增
- 以文字作标识，正看芯片下排引脚的左边第一个脚为“1”，沿逆时针方向递增

## 现场问题处理流程
- 问题排查
    以文字、图形、表格、数据等形式，描述问题排查的步骤，例如初步分析可能导致问题的原因，如何进行排查，排查后是否复现，未复现通过排查了其他什么可能性原因后复现了问题，复现问题后，尝试了哪些解决方案，最终通过什么方案解决了问题。
- 原因分析  
    1. 技术原因：
    以文字、图形、表格、数据等形式，描述问题产生的技术上的原因：需要从问题现象、调试过程，调试效果上进行详细阐述；
    2. 非技术原因：
    分析问题产生的非技术因素，为何设计时遗漏，前期验证时未提早发现；如，设计规范是否完善、开发是否遗漏，测试用例是否完善，有无漏测等，着重关注：为什么没有检查出来，为什么没有测试出来
- 解决方案  
    以文字、图形、表格、数据、会议纪要等形式呈现问题解决方案和回归验证的情况，验证过程，验证结论
- 思考和建议    
    1. 系统内部要保存好各种操作记录，一方面可以作为与客户交涉的有力证据，另一方面利于现场排查和问题定位，提高效率。  
    2. 现场时间同步很重要，务必要保证我们设备的时间与客户的时间保持同步，以利于后续问题的分析与排查。  
    3. 遇到问题，先从接口开始排查，如先后顺序依次可为：  
    来自上层的数据是否有误？  
    -> 向下发送的数据是否有误？  
    -> 内部处理的数据是否有误？  
    -> 输出显示的数据是否有误？......  
    切忌犯主观，遵循数据流。  

## 嵌入式软件架构设计-程序分层
**1.前言**  
在嵌入式MCU软件开发过程中，程序分层设计也是重中之重，关系到整个软件开发过程中的协同开发，降低系统软件的复杂度（复杂问题分解）和依赖关系、同时有利于标准化，便于管理各层的程序，提高各层逻辑的复用等。

**2.分层介绍**  

**2.1硬件抽象层（HAL）**  
嵌入式开发的核心就是芯片，它提供固定的片内资源（常用的有I/O，ISR，TIMER等，稍微好点的还有ADC，SPI等硬件资源，不需要芯片外围ADC采集芯片或模拟SPI）共开发者使用。而且它具有一个很重要的特点就是，不随项目的新增需求变动而变动。所以应将其作为最底层，为上层提供基础支持。

大部分情况下该层都会有芯片厂商提供相应的库函数包或者配置工具生成对应API函数，基本只要知道如何配置和使用就行，当然，也有可能存在芯片厂商提供的库函数包或配置工具配置/使用自由度不高，需要自己查看芯片寄存器手册增加自己需要的API函数。

**2.2 硬件驱动层（HDL）**  
嵌入式开发通常都会使用片外资源，用来弥补硬件抽象层实现不了的功能或者需要扩展的功能。

如AT24C02，W25Q128等常见的外围EEPROM芯片，需要SPI通信（硬件SPI或I/O模拟的SPI）发送相应指令驱动该芯片，实现该芯片能正常工作。因此驱动这部分的API函数实现程序即为硬件驱动层。即使换了MCU，也只需将调用过硬件抽象层的API函数替换即可。

**2.3 功能模块层（FML）**  
硬件抽象层和驱动层主要就是为功能模块层提供的，实现该项目需要的基本功能。而这一层又为上层提供最基本的功能，各功能模块之前没有太多联系。

比如KEY、LED和EEPROM等功能，其中KEY、LED基本调用硬件抽象层的API函数（更复杂的可能通过片外芯片获取/控制等，因此可能也需要使用硬件驱动层），EEPROM调用硬件驱动层的API函数，即使EEPROM芯片更换（AT24C02或W25Q128等），也不影响EEPROM之前编写含的功能代码程序（前提是AT24C02，W25Q128提供的API函数提供的是统一标准）。

**2.4 应用程序层（APL）**  
应用程序层主要负责的就是功能模块的使用和之间的逻辑关系处理等等，比如用户交互界面应用程序可能需要按键（KEY）、指示灯（LED）、显示屏（LCD）等，实现一系列的人机交互功能，通常应用程序层相对于功能模块层而言独立性较低。

一般情况下也可细分出应用业务层，但是对于单片机产品来说，这一层的必要性反而不高，分层太多，反而显得臃肿。

**3 总结**

**3.1 硬件抽象层和硬件驱动层的主要区别**  
硬件抽象层使用的芯片内本身的资源（芯片手册都有介绍），而硬件驱动层使用的是芯片本身不存在的资源，而且需要编写相应代码才能实现的资源。

比如正点原子STM32中CAN使用的TJA1050芯片，CAN属于STM32的片内资源，TJA1050属于片外资源，但由于TJA1050不需要额外的代码就能通过STM32中CAN本身提供API函数正常 工作；因此可以认为TJA1050不属于硬件驱动层，而若使用TJA1041，则需要编写额外代码才能使正常工作才能使STM32中CAN本身提供API函数正常工作，因此可以将TJA1041归为硬件驱动层。

**3.2 功能模块层和硬件抽象层、硬件驱动层的主要区别**  
功能模块层是按照项目需求提取出来的功能，需要硬件抽象层和硬件驱动层的硬件支持才能实现，功能模块层根据项目的功能需求改变而改变，而硬件抽象层和硬件驱动层则是项目需求书中的功耗等硬件相关的需求变动而改变，当然，若子功能的增加而硬件不支持，则也需更换硬件驱动。

比如项目中的数据储存功能，硬件支持有AT24C02、W25Q128和芯片本身的FLASH，都可以支持数据储存功能，即使后期因为功耗或节约成本等问题，硬件的更换也不影响数据储存功能的实现（前提规划好标准规范的API函数定义）且避免了重写该功能代码所带来的各种问题，保证了该功能的稳定性。

## EXCEL CONCAT组合公式
EXCEL，使用CONCAT公式自动组合生成一列 0-1、2-3、3-4
```
使用自动填充在A1生成一列0、2、4...
使用自动填充在B1生成一列1、3、5...
使用公式在C1自动填充  =CONCAT(A1,"-",B1)
```
