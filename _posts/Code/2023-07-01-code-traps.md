---
title: "Code Traps"
description: 
date: 2023-07-01 10:00:00 +0800
categories: [Code, Traps]
tags: [Code, Traps]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

- 在多线程编程下,要注意缓存buf不能进行复用,容易产生污染数据,或着在同一个缓存buf的不同操作中使用互斥锁进行保护

- hex文件无法烧录：排查线序，J-LINK, 接线, J-FLASH。问题：J-FLASH版本为v7.88，版本太高导致软件中止烧录，降级v7.66后，问题解决。

- 在继电器输出后需要进行一定的延时，以等待DO的输出变化完全稳定,不能立刻去读取这个输出,可能会不准确(DI-DO互连的工厂测试场景下)

- 读取DI输入时需要进行多次消抖处理，防止抖动误报（尤其是会触发联动动作时）

- 产生了一个`*_p_u8_Buf`不小心改成`_u16_Len`，数组索引采用16位，而数组仅有256字节，从而导致数组索引越界，程序跑飞的问题

- DI读取需要进行防抖处理，在接线较长或者出现高压时，易出现抖动，读取输入一般需要做防抖。

- 拨码地址读取时需要进行先在临时变量中，读取完成后再更新至全局变量，防止抖动

- 可能会导致程序产生问题的地方： 大电流的功率线产生信号上的干扰，影响了程序的逻辑判断状态或者数据传输

- Flash内存地址区域的划分，一定要认真考虑分配的大小，否则如果后续需要扩展划分的区域大小，可能会产生兼容性问题，尤其是涉及系统重要标志位的存储地址
>如升级标志位的地址发生改变，将会引发一系列升级问题
    1. 无法使用IAP升级
    2. 旧内存分配版本升级到新内存分配版本时，即使是烧录升级，也需要整片擦除后重新烧录，将Flash内残留的旧版本保存的标志位一并清除，防止引发错误bug（新版本下的boot，跳转到core和app失败，超过重试次数后，认为内核损坏，在内部FLASH写入了需要升级文件的标志位，此时即使烧录了新的core和app，但是标志位未被清除，boot不会再执行跳转。）

- 定义了DEBUG宏，但其为关键字，因此不能使用该名称，改为DEBUG_SWITCH

- 互斥锁mutex  
    如果一类数据，可能会被多个线程操作修改，那么必须使用互斥锁，来保证数据在修改过程中不被其他线程抢占。  
    对于modbus通信类的任务，如果在多个线程中同时读/写操作，有可能会导致缓冲队列产生异常，从而校验失败，如果没有及时清除缓存，甚至会出现无法再重新校验成功的问题。  

    互斥锁会产生优先级翻转现象，锁的获取和释放要尽可能快速，否则会影响系统的实时性。

-  结果校验
    由于在代码中添加了返回结果校验，因此在调试时发现某个485从设备的一处重大bug（从设备在返回数据时未附上校验，导致解析返回数据的结果恒为失败），因此对于所有代码中的返回结果，完善其返回校验代码，结果校验十分重要，不可忽略。
    >以前只对外部寄存器调用写函数，未判断该接口的返回值，因此此问题一直未暴露  
    >总结：在判断正确的返回结果再继续向下执行，对异常值需要进行处理

- 在有互斥锁操作的代码范围内，谨慎使用return，防止提前退出未释放锁的错误

- 数组越界，没有报警，但是访问到了其他变量的空间上的数据，可能会产生功能结果上的错误

- 代码编写完成后使用cppcheck进行静态检查

- 对外界的输入要保持怀疑和不信任态度

- 对于所有的数据DI输入，都需要进行软件滤波，提高数据稳定度

- 对于外界从设备输入的数据，默认不能信任，对数据进行过滤（不管输入设备自身是否消抖），对于超阈值的数值，需要判断其连续N次满足消抖后再使用

- 对于从设备上电初始化的值，不能马上使用，要考虑从设备本身初始化稳定所需的时间（上电初始化时可能有异常值，可能产生错误报警）

- 重大失误导致hard fault
    对一个传入指针解引用，导致了hard fault。  
    问题解析:  
    该指针实际上是正常的变量的地址，出现hard fault的原因为在打印时将该变量解释为“%s”字符串，`printf()`遇到结尾符号`'\0'`才停止显示打印，因此在找到字符串结束符`'\0'`前，该指针被不断递增和解引用，最终访问了不合法的区域，导致了hard fault。  
    ![输入图片说明](/imgs/code-traps/2023-11-24/sMBTvOmevEwBlFE4.png)  

    [# Cortex-M 处理器 hardfault 定位方法和步骤（基于Keil mdk）](https://blog.csdn.net/supermuscleman/article/details/103929606)

- 在测试软件各方面没问题，且在另一块开发板上能够正常运行时，要考虑是否存在硬件外设损坏的可能

- SPIFLASH写失败问题
使用FATFS存放下载的IAP升级文件，测试升级失败工况（升级下载文件过程断电）次数多了导致文件系统容量永久丢失（下载过程中对芯片正常重启不会导致丢失）
>原因：文件open后没有close就断电了，信息没有同步到文件系统的信息表里面，就会导致文件系统容量丢失，需要格式化文件系统后才能找回
>
>解决：加上异常处理，如果文件写入失败要check一下文件系统剩余空间，剩余空间为0时格式化文件系统，或者检测文件可用容量，当检测到泄露一定容量时直接进行格式化

- SD卡未插入，或者写入异常时，程序会异常崩溃。提示：异常操作一定要处理

- 变量初始化（尤其是数组和结构体）  
    所有的全局变量和静态变量，甚至局部变量，在初始化阶段或者首次使用前，都要根据实际情况初始化为0或者设计初始值，然后才能使用。而不能依赖编译器来做。编译器能保障芯片重启的初始值，但不能保障固件热重启的初始值。软件编码应该规避编译器的差异，主动权掌握在自己手里。  

- efuse烧写
双MCU芯片方案时，需要关注次MCU的启动方式引脚，若决定启动方式的引脚被用于与主MCU进行串口通信，则从MCU单独上电时，主MCU若已经在持续发送通讯数据，则通信数据有概率会影响次MCU判断启动方式，可能导致次MCU无法启动
> 解决方案：在次MCU的boot内增加efuse烧写的检测与调用，在efuse上写死启动方式来避开启动方式引脚的影响。

- 调试模式冻结软件看门狗可能导致未发现的问题  
经过芯片配置，KEIL在进入调试模式后会禁止软件看门狗的使能，与正常发版的软件运行情况并不能说是完全一致的  
> 例如：某外设由于异常问题导致初始化时间过长，导致软件看门狗一直重启，无法跳转进入app运行  
>
>软件看门狗问题验证手段：不进入调试模式并调整将软件看门狗的超时时间加长，观察芯片是否可以正常启动）

- 外设初始化失败可能的原因
    1. 软件驱动问题
    2. 硬件虚焊，接触不良

- 内存泄漏
    1. 使用malloc分配内存后没有进行释放
    2. 解析WEB JSON数据时使用完JSON对象没有进行销毁

- 代码要经过多人审查、多人Review,涉及到动态内存使用的地方要非常慎重（否则可能会带来内存泄漏类的严重后果，还需花费大量时间精力排查，一旦到客户现场，影响面更大）

- 系统的硬件资源消耗（如CPU使用率、内存等）需要列入checklist&测试用例

- 操作指针要十分注意内存越界，在操作数组时需要尤为注意

- 不同功能/线程不得使用同一块缓存buf，可能会导致数据混乱，如果必须使用同一块缓存，必须添加互斥锁机制并充分测试
>当两个通信从设备若使用同一块缓存进行数据接收时，若单板条件/从设备没有全部接上，不会暴露出缓存混乱的问题

- 在同一个芯片上进行生产测试自动代码开发，将不同的485通道对托测试时，需要在
1. 主从机功能均要设置超时时间，若不设置默认为无限等待，若错过或未接收到发送过来的数据，就可能会导致从机读取线程一直被阻塞，无限等待
2. 同一个MCU的485芯片引脚电平切换需要时间，在回复数据函数前应进行适当延时，等待485芯片读写引脚电平切换后，再进行回复，否则会导致数据丢失

- 系统日志的输出与否一定程度上会影响整体系统的一致性，尤其是在通信相关功能的时序配合上
>例如485芯片的读/写使能引脚的电平转换需要一定时间，根据电路阻容的差异不同1.5ms/6us，当电平转换需要1.5ms以上时，则从机必须在1.5ms后才能开始回复数据，否则会丢失数据

- 485通道上不同设备之间需要考虑读取间隔，根据从设备性能及其实现代码的性能差异而有不同

- Debug模式和Release模式编译处理可能个不一样，因此可能出现Debug模式下没有问题，正式发布上线后就有问题
>研发开发的时候为了方便可以用Debug模式，但给测试部测试的时候一定要用Release模式，否则就可能出现上述问题
