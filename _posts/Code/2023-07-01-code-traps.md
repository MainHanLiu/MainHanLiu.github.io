---
title: "Code Traps"
description: 
date: 2023-07-01 10:00:00 +0800
categories: [Code, Traps]
tags: [Code, Traps]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text under the image
---

- 在多线程编程下,要注意缓存buf不能进行复用,容易产生污染数据,或着在同一个缓存buf的不同操作中使用互斥锁进行保护

- hex文件无法烧录：排查线序，J-LINK, 接线, J-FLASH。问题：J-FLASH版本为v7.88，版本太高导致软件中止烧录，降级v7.66后，问题解决。

- 在继电器输出后需要进行一定的延时，以等待DO的输出变化完全稳定,不能立刻去读取这个输出,可能会不准确(DI-DO互连的工厂测试场景下)

- 读取DI输入时需要进行多次消抖处理，防止抖动误报（尤其是会触发联动动作时）

- 产生了一个`*_p_u8_Buf`不小心改成`_u16_Len`，数组索引采用16位，而数组仅有256字节，从而导致数组索引越界，程序跑飞的问题

- DI读取需要进行防抖处理，在接线较长或者出现高压时，易出现抖动，读取输入一般需要做防抖。

- 拨码地址读取时需要进行先在临时变量中，读取完成后再更新至全局变量，防止抖动

- 可能会导致程序产生问题的地方： 大电流的功率线产生信号上的干扰，影响了程序的逻辑判断状态或者数据传输

- Flash内存地址区域的划分，一定要认真考虑分配的大小，否则如果后续需要扩展划分的区域大小，可能会产生兼容性问题，尤其是涉及系统重要标志位的存储地址
>如升级标志位的地址发生改变，将会引发一系列升级问题
    1. 无法使用IAP升级
    2. 旧内存分配版本升级到新内存分配版本时，即使是烧录升级，也需要整片擦除后重新烧录，将Flash内残留的旧版本保存的标志位一并清除，防止引发错误bug（新版本下的boot，跳转到core和app失败，超过重试次数后，认为内核损坏，在内部FLASH写入了需要升级文件的标志位，此时即使烧录了新的core和app，但是标志位未被清除，boot不会再执行跳转。）

- 定义了DEBUG宏，但其为关键字，因此不能使用该名称，改为DEBUG_SWITCH

- 互斥锁mutex  
    如果一类数据，可能会被多个线程操作修改，那么必须使用互斥锁，来保证数据在修改过程中不被其他线程抢占。  
    对于modbus通信类的任务，如果在多个线程中同时读/写操作，有可能会导致缓冲队列产生异常，从而校验失败，如果没有及时清除缓存，甚至会出现无法再重新校验成功的问题。  

    互斥锁会产生优先级翻转现象，锁的获取和释放要尽可能快速，否则会影响系统的实时性。

-  结果校验
    由于在代码中添加了返回结果校验，因此在调试时发现某个485从设备的一处重大bug（从设备在返回数据时未附上校验，导致解析返回数据的结果恒为失败），因此对于所有代码中的返回结果，完善其返回校验代码，结果校验十分重要，不可忽略。
    >以前只对外部寄存器调用写函数，未判断该接口的返回值，因此此问题一直未暴露  
    >总结：在判断正确的返回结果再继续向下执行，对异常值需要进行处理

- 在有互斥锁操作的代码范围内，谨慎使用return，防止提前退出未释放锁的错误

- 数组越界，没有报警，但是访问到了其他变量的空间上的数据，可能会产生功能结果上的错误

- 代码编写完成后使用cppcheck进行静态检查

- 对外界的输入要保持怀疑和不信任态度

- 对于所有的数据DI输入，都需要进行软件滤波，提高数据稳定度

- 对于外界从设备输入的数据，默认不能信任，对数据进行过滤（不管输入设备自身是否消抖），对于超阈值的数值，需要判断其连续N次满足消抖后再使用

- 对于从设备上电初始化的值，不能马上使用，要考虑从设备本身初始化稳定所需的时间（上电初始化时可能有异常值，可能产生错误报警）

- 重大失误导致hard fault
    对一个传入指针解引用，导致了hard fault。  
    问题解析:  
    该指针实际上是正常的变量的地址，出现hard fault的原因为在打印时将该变量解释为“%s”字符串，`printf()`遇到结尾符号`'\0'`才停止显示打印，因此在找到字符串结束符`'\0'`前，该指针被不断递增和解引用，最终访问了不合法的区域，导致了hard fault。  
    ![输入图片说明](/imgs/code-traps/2023-11-24/sMBTvOmevEwBlFE4.png)  

    [# Cortex-M 处理器 hardfault 定位方法和步骤（基于Keil mdk）](https://blog.csdn.net/supermuscleman/article/details/103929606)

- 在测试软件各方面没问题，且在另一块开发板上能够正常运行时，要考虑是否存在硬件外设损坏的可能

- SPIFLASH写失败问题
使用FATFS存放下载的IAP升级文件，测试升级失败工况（升级下载文件过程断电）次数多了导致文件系统容量永久丢失（下载过程中对芯片正常重启不会导致丢失）
>原因：文件open后没有close就断电了，信息没有同步到文件系统的信息表里面，就会导致文件系统容量丢失，需要格式化文件系统后才能找回
>
>解决：加上异常处理，如果文件写入失败要check一下文件系统剩余空间，剩余空间为0时格式化文件系统，或者检测文件可用容量，当检测到泄露一定容量时直接进行格式化

- SD卡未插入，或者写入异常时，程序会异常崩溃。提示：异常操作一定要处理

- 变量初始化（尤其是数组和结构体）  
    所有的全局变量和静态变量，甚至局部变量，在初始化阶段或者首次使用前，都要根据实际情况初始化为0或者设计初始值，然后才能使用。而不能依赖编译器来做。编译器能保障芯片重启的初始值，但不能保障固件热重启的初始值。软件编码应该规避编译器的差异，主动权掌握在自己手里。  

- efuse烧写
双MCU芯片方案时，需要关注次MCU的启动方式引脚，若决定启动方式的引脚被用于与主MCU进行串口通信，则从MCU单独上电时，主MCU若已经在持续发送通讯数据，则通信数据有概率会影响次MCU判断启动方式，可能导致次MCU无法启动
> 解决方案：在次MCU的boot内增加efuse烧写的检测与调用，在efuse上写死启动方式来避开启动方式引脚的影响。

- 调试模式冻结软件看门狗可能导致未发现的问题  
经过芯片配置，KEIL在进入调试模式后会禁止软件看门狗的使能，与正常发版的软件运行情况并不能说是完全一致的  
> 例如：某外设由于异常问题导致初始化时间过长，导致软件看门狗一直重启，无法跳转进入app运行  
>
>软件看门狗问题验证手段：不进入调试模式并调整将软件看门狗的超时时间加长，观察芯片是否可以正常启动）

- 外设初始化失败可能的原因
    1. 软件驱动问题
    2. 硬件虚焊，接触不良

- 内存泄漏
    1. 使用malloc分配内存后没有进行释放
    2. 解析WEB JSON数据时使用完JSON对象没有进行销毁

- 代码要经过多人审查、多人Review,涉及到动态内存使用的地方要非常慎重（否则可能会带来内存泄漏类的严重后果，还需花费大量时间精力排查，一旦到客户现场，影响面更大）

- 系统的硬件资源消耗（如CPU使用率、内存等）需要列入checklist&测试用例

- 操作指针要十分注意内存越界，在操作数组时需要尤为注意

- 不同功能/线程不得使用同一块缓存buf，可能会导致数据混乱，如果必须使用同一块缓存，必须添加互斥锁机制并充分测试
>当两个通信从设备若使用同一块缓存进行数据接收时，若单板条件/从设备没有全部接上，不会暴露出缓存混乱的问题

- 在同一个芯片上进行生产测试自动代码开发，将不同的485通道对托测试时，需要在
1. 主从机功能均要设置超时时间，若不设置默认为无限等待，若错过或未接收到发送过来的数据，就可能会导致从机读取线程一直被阻塞，无限等待
2. 同一个MCU的485芯片引脚电平切换需要时间，在回复数据函数前应进行适当延时，等待485芯片读写引脚电平切换后，再进行回复，否则会导致数据丢失

- 系统日志的输出与否一定程度上会影响整体系统的一致性，尤其是在通信相关功能的时序配合上
>例如485芯片的读/写使能引脚的电平转换需要一定时间，根据电路阻容的差异不同1.5ms/6us，当电平转换需要1.5ms以上时，则从机必须在1.5ms后才能开始回复数据，否则会丢失数据

- 485通道上不同设备之间需要考虑读取间隔，根据从设备性能及其实现代码的性能差异而有不同

- Debug模式和Release模式编译处理可能个不一样，因此可能出现Debug模式下没有问题，正式发布上线后就有问题
>研发开发的时候为了方便可以用Debug模式，但给测试部测试的时候一定要用Release模式，否则就可能出现上述问题

- 不能盲目遵守所有大型变量申请后需要进行memset初始化的规则
>static结构体无法直接赋值0初始化，但也不能使用memset，否则会每次执行前都清零，不再具有static属性

- 如果两个头文件互相包含，可能会导致其报错某类型未定义

- 组织好头文件之间的包含层次关系，不能随意包含和过度包含

- 指针在使用过后要注意已经不是指向开头的位置
> 若对一个变量取地址&赋值给一个指针，且这个指针进行了移动，要注意指针移动后不再指向第一个元素位置，因此再次强制转换回原始数据类型的操作是错误的

- 必须要执行的函数不能写进含有或条件的判断语句中，可能会不执行(当前面有条件判断为TRUE时，后面判断不会执行)
```c
if (flag == 1
|| SF_TRUE == fun1()
|| SF_TRUE == fun2())
```

- 通信协议的变更一定要谨慎，尤其是寄存器位置的重排，需要考虑供应商的能力以及新软件可能无法稳定运行且无法解决时的兼容性问题，预留回退的余地

- 宏定义不能通过分支判断的形式选择不同的定义
>宏定义在预处理阶段即被处理

下列写法是错误的，使用if条件判断选择宏定义的不同处理方式是无效的，此处会无条件被重新宏定义
```c
if (1 == flag)
    {
        #undef STOP_PREPARE_5_MINUTE
        #undef STOP_PREPARE_10_MINUTE
        #define STOP_PREPARE_5_MINUTE  (120 * 1000)   
        #define STOP_PREPARE_10_MINUTE (240 * 1000)
    }   
```
