---
title: "常量后缀 U L UL F"
description: ""
date: 2023-08-08 10:00:00 +0800
categories: [Code, Common]
tags: [Code, Common]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

## **常量后缀 U L UL F**  
1UL 0U 1f 1L（大小写皆可）：后缀是为了明确告诉编译器用什么编码存储这些数值字面量。否则编译器就用默认编码保存。  
    
## **C语言中常量的默认情况：**  
整形默认为有符号int；  
浮点型默认为double;  
如果整形常量大小超出int，默认自然就为long int；  
如果需要无符号整形常量的话就可以在常量后面加u或是U，如0u或是0U，同理可以在常量后面加ul或UL表示无符号长整形常量；而浮点型常量后缀只有f或F，l或L（long double），没有u或U，因为浮点数一般都为有符号。  
- 数值后面加“L”和“l”（小写的l）的意义是该数值是long型。  
    详细说明如下：  
    5L的数据类型为long int。  
    5.12L的数据类型为long double。  

 

## **后缀与强制类型转换解释**
- 后缀是为了明确告诉编译器用什么编码存储这些数值字面量。否则编译器就用默认编码保存，例如整数通常是补码。  
- 强制类型转换，是为了告诉计算此二进制数据是什么编码，例如(int),就表明此编码是补码编码。 

`-2+1u > 0`为什么永远为`true` ？  
-2在内存中补码编码存储为`0xfffffffe`，  
1在内存中无符号编码存储为`0x00000001` （这个补码编码和无符号编码都一样），  
0在内存中补码编码存储为`0x00000000`，  
计算-2 + 1 ，加法器可没那么聪明，不管你是什么编码，就正常加起来。这样存储在内存中的值`0xffffffff`，  
但你这里加了一个u，最后的计算结果`0xffffffff`要看作一种无符号的编码，进行后面的大小判断运算。在csapp中叫做`B2U_32`函数，专门把无符号编码的二进制转成对应的整数。`B2U_32(0xffffffff)`结果就是`4294967295`。`B2U_32(0x00000000)`结果就是`0`，  
`4294967295` 肯定大于 `0`。  

另外说下`(int) 2147483648u`，首先看后缀u,说明要把此数作为无符号编码存储在内存中就是`0x80000000` 。再看前缀强制转成int，换句话说就是把`0x80000000`当作补码编码，在csapp中叫做B2T_32函数，专门把补码编码的二进制转成对应的整数。`B2T_32(0x80000000) = -2147483648` .可以在gdb下输入`print (int) 2147483648u`验证下，就是-2147483648。  

再说下`-1u`，这个编译器是有点懵逼的？？不知道怎么给-1进行无符号编码，算了不听你的，-1在内存中还是用补码编码吧，存储为 `0xffffffff` 。但是后缀加了`u`，说明你想让计算机把`0xffffffff`当作一个无符号整数。 `B2U_32(0xffffffff) = 4294967295`。可以在gdb下输入print -1u测试就是4294967295。  
