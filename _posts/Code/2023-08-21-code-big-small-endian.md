---
title: "大小端"
description: 
date: 2023-08-21 10:00:00 +0800
categories: [Code, Common]
tags: [Code, Common, 大小端]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

##  MSB & LSB

对于涉及 bit 流的概念中:
- MSB（Most Significant Bit）  
最高有效位，二进制中代表最高值的比特位，这一位对数值的影响最大。
- LSB（Least Significant Bit）  
最低有效位，二进制中代表最低值的比特位。

对于涉及 byte 流的概念中:
- MSB（Most Significant Byte）  
多字节序列中最高权重的一个字节。  
- LSB（Least Significant Byte）  
多字节序列中最小权重的字节。

![输入图片说明](/imgs/code-big-small-endian/2024-10-22/hkmq7Rn6YMaMFrcg.png)


## 字节序 : 大端 & 小端
字节序，指的是占用多个字节的数据在嵌入式设备的内存中或在网络通信链路中的字节排列顺序。  

**内存增长顺序/网络发送顺序**  
在内存中的高地址和低地址很好区分，而在网络通信中，则是根据发送的顺序确定低地址到高地址。
>发送字节时，先发送的认为是**低地址**，后发送的认为是**高地址**  
发送字节的序号编为 Byte0  ->  Byte1  ->  Byte2  ->  Byte3

>计算机正常的内存增长方式是从低地址到高地址(当然栈不是)，取数据方式是从基址根据偏移找到他们的位置。

**高位 低位**  
在十进制中靠左边的是高位，靠右边的是低位，在其他进制也是如此。  
就拿 0x12345678来说，一共有 4 个字节，这四个字节按照字面值的 **高位 -> 低位** 的顺序分别是：0x12、0x34、0x56、0x78。

**大端 小端**
- 大端(big endian)  
高位字节排放在低地址端，即网络字节序。  
>TCP/IP协议，RFC1700规定使用**大端**字节序为网络字节序  

- 小端(little endian)  
低位字节排放在低地址端，即主机字节序。  

>记忆：低低小

| 0x12345678  | 低地址 | ——内存增长顺序/网络发送顺序——> | 高地址 |
|--|--|--|--|
| 大端（网络字节序） | 高位0x12 | ——————> | 低位0x78 |
| 小端（主机字节序） | 低位0x78 | ——————> | 高位0x12 |

大端小端没有谁优谁劣，各自优势便是对方劣势：  
- 小端模式 ：  
强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。  
第一个字节是它的低位，符号位在最后一个字节，这样在做数值四则运算时，从低位每次取出相应字节运算，最后直到高位，并且最终把符号位刷新，这样的运算方式会更高效。  
- 大端模式 ：  
符号位的判定固定为第一个字节，容易判断正负。  

大端和小端实际上是字节顺序与存储地址顺序相对应的两种模式，但是不管是大端还是小端，**数据一定是从内存的低地址依次向高地址读取和写入**。  

向内存地址为**0x1000**的地址写入**0x12345678**这个四字节16进制数（注意内存地址是递增还是递减）  
16进制，两个数就是一字节  
字节高低位： 一般左边为高位，右边为低位  
>高字节——>低字节： 12 34 56 78  

| 内存地址 | 大端 | 小端 |
|--|--|--|
| 0x1000 | 12 | 78 |
| 0x1001 | 34 | 56 |
| 0x1002 | 56 | 34 |
| 0x1003 | 78 | 12 |

>大端符合传输阅读顺序(先发送的是高位)，小端符合既视阅读顺序（高地址的是高位）。  

已知内存数据，未知真实数据，则：  

| 内存地址 | 原始数据 |
|--|--|
| 0x1000 | 78 |
| 0x1001 | 56 |
| 0x1002 | 34 |
| 0x1003 | 12 |
|  |  |
| 大端 | 0x78563412 |
| 小端 | 0x12345678 |

现在主流的CPU，intel系列的是采用的little endian的格式存放数据，ARM则同时支持 big和little，网络编程中，TCP/IP统一采用大端方式传送数据，所以有时我们也会把大端方式称之为网络字节序。
>一般我们用的x86结构的都是小端模式

C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而 JAVA编写的程序则唯一采用big endian方式来存储数据。  

## **判断大小端**  
联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写  
```c
BOOL IsBigEndian()
{
    union NUM
    {
        int a;
        char b;
    }num;
    num.a = 0x1234;
    if( num.b == 0x12 )
    {
        return TRUE;
    }
    return FALSE;
}
```
## **大小端转换**  
对于字数据（16位）：  
```c
#define BigtoLittle16(A) ((((uint16)(A) & 0xff00) >> 8) | \
(( (uint16)(A) & 0x00ff) << 8))
```
对于双字数据（32位）：
```c
#define BigtoLittle32(A) ((( (uint32)(A) & 0xff000000) >> 24) | \
(( (uint32)(A) & 0x00ff0000) >> 8) | \
(( (uint32)(A) & 0x0000ff00) << 8) | \
(( (uint32)(A) & 0x000000ff) << 24))
```

## 将字节组合成大小端数据
通过将原来的大小端数据正确排布并进行强制类型转换，从而获得正确的数据分布
```c
// 将2字节数组(大端Big Endian次序，高字节在前)转换为16位整数
uint16_t BEBufToUint16(uint8_t *_pBuf)
{
    return (((uint16_t)_pBuf[0] << 8) | _pBuf[1]);
}
```
```c
//将2字节数组(小端Little Endian，低字节在前)转换为16位整数
uint16_t LEBufToUint16(uint8_t *_pBuf)
{
    return (((uint16_t)_pBuf[1] << 8) | _pBuf[0]);
}
```

## CAN总线常见的两种编码格式(Intel/Motorola)
在汽车电子行业的开发或者测试中，我们经常会看到CAN总线信号的常见的两种编码格式：**Intel格式与Motorola格式**。  
1. 当一个信号的长度不超过1个字节(8bit),且不跨字节时，Intel格式与Motorola格式编码结果是完全一样的  
2. 当一个信号的长度不超过1个字节(8bit),但是跨字节时，Intel格式与Motorola格式编码结果是不一样的  

### Motorola格式(类似于大端模式)：从高地址开始存储
数据还原规则为 Byte0-bit7至bit0  组合 Byte1-bit7
![输入图片说明](/imgs/code-big-small-endian/2024-10-22/FpljoWDNXf5dqMY5.png)

### Intel格式(类似于小端模式)：从低地址开始存储
数据还原规则为 Byte1-bit0  组合 Byte0-bit7至bit0 
![输入图片说明](/imgs/code-big-small-endian/2024-10-22/bfhKAQnHGuulWOSC.png)

![输入图片说明](/imgs/code-big-small-endian/2024-10-22/FHgvKc15WtQrTgIH.png)

参考：# [CAN总线常见的两种编码格式(Intel/Motorola)](https://www.cnblogs.com/MySunday/p/15656645.html )
