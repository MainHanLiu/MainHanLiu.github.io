---
title: "大小端"
description: 
date: 2023-08-21 10:00:00 +0800
categories: [Code, Common]
tags: [Code, Common, 大小端]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

大端(big endian)：高位字节排放在内存的低地址端，即网络字节序。  
小端(little endian)：低位字节排放在内存的低地址端，即主机字节序。  
记忆：低低小，大端符合传输阅读顺序，小端符合既视阅读顺序  

现在主流的CPU，intel系列的是采用的little endian的格式存放数据，ARM则同时支持 big和little，网络编程中，TCP/IP统一采用大端方式传送数据，所以有时我们也会把大端方式称之为网络字节序。（一般我们用的x86结构的都是小端模式）  

C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而 JAVA编写的程序则唯一采用big endian方式来存储数据。  

大端小端没有谁优谁劣，各自优势便是对方劣势：  
小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。  
大端模式 ：符号位的判定固定为第一个字节，容易判断正负。  

大端和小端实际上是字节顺序与存储地址顺序相对应的两种模式，但是不管是大端还是小端，**数据一定是从内存的低地址依次向高地址读取和写入**。  

向内存地址为**0x1000**的地址写入**0x12345678**这个四字节16进制数（注意内存地址是递增还是递减）  
16进制，两个数就是一字节  
字节高低位:一般左边为高位，右边为低位  
高有效字节——>低有效字节： 12 34 56 78  

| 内存地址 | 大端 | 小端 |
|--|--|--|
| 0x1003 | 78 | 12 |
| 0x1002 | 56 | 34 |
| 0x1001 | 34 | 56 |
| 0x1000 | 12 | 78 |

已知内存数据，未知真实数据，则：  

| 内存地址 | 原始数据 |
|--|--|
| 0x1003 | 12 |
| 0x1002 | 34 |
| 0x1001 | 56 |
| 0x1000 | 78 |
| 大端 | 0x78563412 |
| 小端 | 0x12345678 |

大端符合传输阅读顺序，小端符合既视阅读顺序  
**判断大小端**  
联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写  
```c
BOOL IsBigEndian()
{
    union NUM
    {
        int a;
        char b;
    }num;
    num.a = 0x1234;
    if( num.b == 0x12 )
    {
        return TRUE;
    }
    return FALSE;
}
```
**大小端转换**  
对于字数据（16位）：  
```c
#define BigtoLittle16(A) ((((uint16)(A) & 0xff00) >> 8) | \
(( (uint16)(A) & 0x00ff) << 8))
```
对于双字数据（32位）：
```c
#define BigtoLittle32(A) ((( (uint32)(A) & 0xff000000) >> 24) | \
(( (uint32)(A) & 0x00ff0000) >> 8) | \
(( (uint32)(A) & 0x0000ff00) << 8) | \
(( (uint32)(A) & 0x000000ff) << 24))
```
