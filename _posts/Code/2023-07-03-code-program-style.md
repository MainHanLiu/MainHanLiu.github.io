---
title: "Code Riview Reflect"
description: 
date: 2023-07-03 10:00:00 +0800
categories: [Code, Program style]
tags: [Code, Program style]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text under the image
---

## Programming Style
- [# C语言编程规范学习笔记和总结](https://blog.csdn.net/GUA8122HOU/article/details/125888744)

避免使用危险函数sprintf /vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数 snprintf/strncpy/strncat/fgets代替。
 
使用时sizeof或者strlen计算结构/字符串长度，避免手工计算。
 
doxygen格式《Doxygen中文手册》

规则4.2 通讯过程中使用的结构，必须注意字节序。  
说明：通讯报文中，字节序是一个重要的问题，不同设备使用的cpu类型复杂多样，大小端、32位/64位的处理器也都有，如果结构会在报文交互过程中使用，必须考虑字节序问题。由于位域在不同字节序下，表现看起来差别更大，所以更需要注意。对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；接收时，也必须进行网络序到主机序的转换。  
如何处理：通过代码的数据组织方式自行进行协调收发数据的字节排列

如何关注：  
必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等
>coredump配置、产生、分析

**单元测试要求**  
单元测试是开发者最容易忽略的问题，通常要求新增代码的单测覆盖率至少达到70%。写好单元测试用例可以帮助开发者提高代码质量，减少低级bug，减少调试时间。

**代码健壮性**  
通常只有20%的代码用来实现核心逻辑，而80%的代码用来保证程序安全。  
实现了核心逻辑之后，代码的健壮性也是一个不可忽略的指标。可以关注以下几个方面：  
1.  是否有判空和异常传参校验
2.  逻辑边界是否完整
3.  是否存在线程安全问题
4.  是否存在并发调用问题
5.  是否需要支持幂等
6.  是否存在内存泄露风险
7.  是否有资源边界限制
8.  是否存在数据一致性问题
9.  是否需要增加限流、熔断、降级等保护机制
10.  是否需要兼容旧逻辑、旧版本

**接口性能问题**  
接口性能也是需要重点关注的问题，可以关注以下几个方面：  
1.  是否存在循环调用（接口、数据库），能否改成批量处理
2.  调用外部接口是否设置合理的超时时间
3.  对外开放的接口，是否预估调用量？是否有保护机制（限流、熔断、降级）？
4.  是否需要增加本地缓存、分布式缓存、多线程、消息队列
5.  打印日志是否过多

**同时，人是不可靠的，所以写测试非常重要。**  
**同上，人是不可靠的，所以静态代码检查非常重要。**  
**同上，人是不可靠的，所以各种自动化的工具非常重要。**  

## 变量命名规则

| 变量类型 | 命名范式 |
|--|--|
| 全局  | g_ |
| 结构体 | _t |
| 指针 | p_u8_name |
| 静态变量 | s_ |

***

## Code Review Reflect

- 在某些时候，相比于复杂算法，如何巧妙地设计和实现一些更加基础的算法和机制，有更大的意义。

- 避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。  

（1）全局变量暴露太多，不同模块之间代码耦合严重  
（2）变量名称作用不清晰，无法理解该变量的作用，在命名不规范的同时还缺乏注释  
（3）flag标志位太多，且其定义处于各个不同的文件中，按照编码规范，应尽可能减少全局变量的使用，使用函数接口来访问和修改变量  
（4）全局函数暴露的太多，对于外部文件不需要调用的函数，应该使用static来限制函数的作用域，仅暴露需要给外部文件访问的变量和函数  
（5）存在.c和.h文件不对应，且函数定义和声明处在不同的模块文件中，有些文件仅存在.c文件，其中函数被其他文件调用，却没有相应的头文件进行对应以供其他文件include，存在头文件中重复声明同一个函数的问题  

- 对于一些标志位的判断，不应该使用0/1，而应该使用enum，使程序更易阅读，FAIL/OK

- 代码文档在项目后期维护以及阅读代码时具有很大的帮助，反之，如果缺少文档，将会带来许多困难

- 代码习惯：在使用接收和发送buf之前要清buf，防止误用导致的错误。

- 代码中使用goto会极大地减弱程序的逻辑，增加阅读和理解难度，在编程中不推荐再使用goto

- 头文件不能包含太多、太复杂、太冗余

- 注意宏的使用,可以增加程序的阅读性,且在多次使用宏代替直接数字的场景下有利于程序的更新

- 一个好的项目代码：功能层次鲜明，不同模块分离，变量定义有序，代码组织有序

- 应该按照功能将代码组织入相应的模块中，不得为了方便任意添加到某处，不利于代码层次的理解

- 封装复用代码

- 对于实现效果类似的模块，应当对其抽象，使用统一接口封装，再传入参数调用  
（降低维护成本/增加可阅读性/简洁代码/确保效果稳定）

- 变量间的层次应该高低分明，且使用时遵从层次关系，不得全部混用，使得变量和代码十分无序

- 对一个已经初步投入运行的项目代码重构，是很需要勇气的，因为不知道潜在的连带风险是否清除干净，如果一开始的代码框架没有设计好，那么随着代码的累加，后续的开发和维护会越来越困难，只能基于最早的框架进行修改，最终屎山只能越建越高

- 在变量最初定义之时，就应该组织好结构体定义并规划好空间，若最开始贪图快捷，不定义结构体直接使用U8/U16的数组，则后续的代码编写每次都需要计算bit位置，极易出错，且一旦bit定义需要重新规划，则适配阻力十分之大，另外代码上下文阅读性奇差，在需要检索指定代码时也十分难定位

- 每个地方的代码安全保护最终才能使得整个程序是健壮的，任何的安全检测疏漏都可能导致“千里之堤，溃于蚁穴”

- 对可能产生竞态情况的代码/变量，需要有敏感性

- 如果一个指针ptr已经被释放，但之后再次调用free(ptr)，如果此时ptr没有被设置为NULL，就会导致双重释放的问题，这是危险的。但如果ptr被设置为NULL，再次调用free(ptr)就是安全的。因此，**良好的习惯是在释放指针后立即将其置为NULL，这样即使不小心再次释放，也不会引发错误**。

- 防御性编程的核心思想在于承认程序总会存在问题和需要修改，因此聪明的程序员会提前考虑并防范可能的错误。它强调在编程过程中不仅要实现功能，还要确保程序在面对错误输入、异常情况和并发操作时能够稳定运行。 

- 在程序开发过程中，最容易出现问题的往往是动态内存分配、内存踩踏、多线程/任务引起的竞态问题，和单个模块的功能设计是否符合预期较容易测试不同，这些问题的排查和修复往往需要花费更多的时间和精力。

- 动态内存分配 malloc memcpy  free 等接口应该再次使用一层封装，通过封装api可以监控动态内存的使用，以及限制内存溢出等问题
