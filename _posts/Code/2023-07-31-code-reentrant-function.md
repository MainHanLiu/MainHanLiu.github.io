---
title: "不可重入函数"
description: ""
date: 2023-07-31 10:00:00 +0800
categories: [Code, C]
tags: [Code, C]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

如果中断处理函数中调用了 printf 函数，因为中断处理函数的调用了不可重入函数，导致中断丢失和系统位置错误，这里直接导致嵌入式 linux 系统应用进程中的所有线程停掉，进而导致看门狗进程得不到喂狗，设备重启。  
## 什么是不可重入函数？  
可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。  
函数不可重入大多数是因为在函数中引用了全局变量。  
满足下列条件的函数多数是不可重入的：  
（a）函数体内使用了静态（static）的数据结构；  
（b）函数体内调用了 malloc() 或者 free() 函数；（malloc，free会引用全局的内存分配表）  
（c）函数体内调用了标准 I/O 函数;（printf会引用全局变量stdout）  
## 中断处理函数不能直接调用不可重入函数  
中断时确实保存一些上下文，但是仅限于返回地址，cpu 寄存器等之类的少量上下文，而函数内部使用的诸如全局或静态变量，buffer 等并不在保护之列，所以如果这些值在函数被中断期间发生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。  
在中断处理函数中调用有互斥锁保护的全局变量，如果恰好该变量正在被另一个线程调用，会导致中断处理函数不能及时返回，导致中断丢失等严重问题。并且在多线程环境中使用，在没有加锁的情况下，对同一段内存块进行并发读写，就会造成 segmentfault/coredump 之类的问题。  
## 如何写出可重入的函数？  
1. 在函数体内不访问那些全局变量； 如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断；  
2. 不使用静态局部变量； 坚持只使用缺省态（auto）局部变量；  
3. 在和硬件发生交互的时候，切记关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用OS_ENTER_KERNAL/OS_EXIT_KERNAL来描述； 不能调用任何不可重入的函数；  
4. 谨慎使用堆栈。最好先在使用前先 OS_ENTER_KERNAL；
