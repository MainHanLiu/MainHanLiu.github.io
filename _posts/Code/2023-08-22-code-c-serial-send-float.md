---
title: "利用联合体通过串口收发浮点数"
description: ""
date: 2023-08-22 10:00:00 +0800
categories: [Code, C]
tags: [Code, C, Float]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---


## **利用联合体通过串口收发浮点数**  
- [#利用联合体通过串口收发浮点数](https://www.cnblogs.com/simonlin/p/5037449.html)  

UART串口有一个缺点，就是发送和接受的单位是一个字节，那么如何发送的浮点数等多字节单位呢（也有可能发送单位是两个字节，同理）  
两种方法，一种是利用指针，一种是利用联合体  

**指针**  
将指向浮点数的指针强制转换为unsigned char *，再通过for循环移动指针进行处理

**联合体（推荐）**  
构建浮点数和uint8数组的联合体，根据场景直接操作联合体  
（联合体union的存放顺序是所有成员都从低地址开始存放的）  

## **浮点数的存储方式**  
- [# IEEE754标准:浮点数在内存中的存储方式，含实例](https://zhuanlan.zhihu.com/p/343033661)  

float,其实指的就是IEEE754标准中的32位单精度浮点数  
double,其实指的就是IEEE754标准中的64位双精度浮点数  
![输入图片说明](/imgs/serial-send-float/2023-08-22/oETXzriXTP3NkkRU.png)  

32位单精度浮点数  
![输入图片说明](/imgs/serial-send-float/2023-08-22/QnKHbFmR1jGcXoka.png)  
这32个二进制位的内存编号从高到低 (从31到0), 共包含如下几个部分:  
>sign: 符号位, 即图中蓝色的方块  
占据最高位(第31位)这一位, 用于表示这个浮点数是正数还是负数, 为0表示正数, 为1表示负数.  

>biased exponent: 偏移后的指数位, 即图中绿色的方块  
指数位占据第30位到第23位这8位。  
8位二进制可以表示256种状态, IEEE754规定, 指数位用于表示[-127, 128]范围内的指数.  
不过为了表示起来更方便, 浮点型的指数位都有一个固定的偏移量(bias), 用于使 指数 + 这个偏移量 = 一个非负整数. 这样指数位部分就不用为如何表示负数而担心了.  
规定: 在32位单精度类型中, 这个偏移量是127. 在64位双精度类型中, 偏移量是1023.   
例如：如果你运算后得到的指数是 -10, 那么偏移后, 在指数位中需要表示为: -10 + 127(偏移量) = 117  

>fraction: 尾数位, 即图中红色的方块  
占据剩余的22位到0位这23位. 用于存储尾数.
在以二进制格式存储十进制浮点数时, 首先需要把十进制浮点数表示为二进制格式；然后, 需要把这个二进制数转换为以2为底的指数形式；  
此外，还需要对尾数做一些特殊处理：  
1.隐藏高位1.  
2.低位补0  
