---
title: "C语言中.h和.c文件解析，编译、链接详解"
description: 
date: 2023-09-05 12:00:00 +0800
categories: [Code, C]
tags: [Code, C, Compile]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

## Preface
　　在进行多文件编程的时候，虽然很多IDE都可以帮我们完成预处理、编译、链接等过程，但深入理解编译器的这几个过程可以避免很多”undefined”，”undeclared”以及”redefined”的问题。而比较好的实践方式是自己写Makefile（IDE实际上完成的就是帮我们弄清文件依赖关系，然后生成一个Makefile，调用编译器去编译链接生成可执行文件）。  
　　编译器在编译时是以C文件为单位进行的，也就是说如果你的项目中一个C文件都没有，那么你的项目将无法编译（编译是以C文件为单位的，如果不在任何C文件中包含此头文件的话，这段代码就形同虚设）。连接器是以目标文件为单位，它将一个或多个目标文件进行函数与变量的重定位，生成最终的可执行文件，在PC上的程序开发，一般都有一个main函数，这是各个编译器的约定，当然，你如果自己写连接器脚本的话，可以不用main函数作为程序入口。  

## 编译器工作原理概述  
1. 预处理阶段：  
　　实际上是处理的是”define”，”include”等宏命令，进行宏替换。例如#include "xx.h"实际意思是把当前这一行删掉，把xx.h中的内容原封不动的插入在当前行位置。  
2. 编译、汇编阶段：  
　　以.c文件为基本单位进行，也就是说如果项目中一个.c文件都没有，那么项目无法编译。这一阶段为所有.c文件中的变量、函数分配空间，并将各个全局变量、函数进行符号描述，编译、汇编成二进制码从而生成.o目标文件。  
　　需要注意的是这个过程并不关心变量的具体定义和函数的具体实现，只要存在变量和函数的相关声明就可以使得编译通过。因为只要知道了变量/函数的类型和名字，编译器就知道了该如何使用这个变量/函数。  
3. 链接阶段:    
　　以.o文件为基本单位进行，将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件，主要的工作就是重定位各个目标文件的函数，变量等，这个过程主要是为上一个编译过程中变量和函数的声明找到他们具体的定义和实现，相当于将各个目标文件中的二进制码按一定的规范合到一个文件中。链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。  

>总结：  
    1、 由.c文件到.i文件，这个过程叫预处理。  
    2、由.i文件到.s文件，这个过程叫编译。  
    3、由.s文件到.o文件，这个过程叫汇编。  
    4、由.o文件到可执行文件，这个过程叫链接。　  

### 举例
```c
// add.h文件

#ifndef _ADD_H
#define _ADD_H

int add(int a, int b);

#endif
```

```c
// add.c文件

#include "add.h"
int add(int a, int b){
    return a + b;
}
```

```c
// main.c文件

#include <stdio.h>
#include "add.h"

int main(){
    int a = 1, b = 2;
    int ans = add(a, b);
    printf("%d\n", ans);

    return 0;
}
```
1. 预处理阶段：  
　　编译器会把main.c和add.c中的#include "add.h"替换成add.h中的全部内容。  
　　编译器以C文件作为一个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个文件，找到之后，就会在相应头文件中再去处理宏，变量，函数声明，嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义与声明的情况发生，最后将那些文件中所有的内容全部扫描进这个当前的C文件中，形成一个中间"C文件"。
2. 编译、汇编阶段：  
　　为main.c和add.c中的各变量和函数分配内存空间并汇编成目标文件。可以发现在main.c中并没有关于add函数的实现只有由#include "add.h"替换成的这个函数的声明，但这并不影响编译过程的进行。
3. 链接阶段：  
　　经过编译后生成了main.o和add.o文件。因为main.o中用到了add函数但没有它的具体实现，所以编译器会去其它.o文件中寻找该函数的具体实现。在这个例子中add.o提供了add函数的具体实现，链接过程顺利进行，生成可执行文件。 
 
## 防止头文件重复包含
关于add.h中#ifndef、#define和#endif的解释：它们的作用是防止头文件在一个.c文件中被重复包含。

### 举例
```c
// a.h文件

struct Node{
    int a;
    int b;
};
```
```c
// b.h文件

#include "a.h"
```
```c
// c.h文件

#include "a.h"
```
```c
// main.c文件

#include <stdio.h>
#include "b.h"
#include "c.h"

int main(){
    print("hello\n");
    return 0;
}
```
　　a.h中有结构体struct Node的定义，b.h和c.h都包含了a.h，main.c中又包含了b.h和c.h这两个头文件。这会导致a.h中的内容被两次复制到main.c中，产生struct Node的重复重复定义错误，而如果a.h遵循下面的格式：  
```c
#ifndef _A_H
#define _A_H

struct Node{
    int a;
    int b;
};

#endif
```
　　那么a.h在main.c中只会被替换一次，这样就避免了头文件的重复包含。

## .h和.c文件解析  
一般情况下我们在.h文件中进行变量、函数和宏的声明，在.c文件中进行变量和函数的具体实现。  

但这只是我们默认的一种规范的做法，实际上我们舍弃.h文件，在.c文件中包含变量、函数的声明以及实现也没有问题，但如果在其它.c文件中用#include去包含这个.c文件就会出现问题。  

### 举例
```c
// add.c文件

int add(int a, int b);

int add(int a, int b){
    return a + b;
}
```
```c
// main.c文件

#include "add.c"

int main(){
    int a = 1, b = 2;
    int ans = add(a, b);
    printf("%d\n", ans);

    return 0;
}
```
　　链接过程会出现add函数重复定义的错误，因为编译后生成的main.o和add.o中都含有add函数的具体实现。这种情况下可以对main.c做如下修改:
```c
int add(int a, int b);

int main(){
    int a = 1, b = 2;
    int ans = add(a, b);
    printf("%d\n", ans);

    return 0;
}
```
　　这样编译后生成的main.o文件中便不再包含add函数的实现，而只包含声明。但是如果add.c中的函数很多，以及调用这些函数的.c文件也很多，这样在每个.c文件中手动挨个添加这些函数的声明会十分不方便，而可以理解为.h文件就是为了声明函数和变量方便而创建的，因为这样把所有的变量、函数声明都写在.h中，其它.c文件只需要#include相应的.h文件就好。

>  
Q：ifndef后面的标识必须是_ADD_H这种头文件名大写加下划线的形式吗？  
A：不必，你可以自定义，这只是一种习惯性写法，因为一个工程中头文件名是不会重复的，所以这样定义的话标识也不会重复。  
>
>Q：工程中可以没有.h文件吗？  
A：可以，只是如上所说这样会有很多不方便。  
>
>Q：.h文件必须和相应的.c文件同名吗？  
A：不必，但是通常我们都这样做，因为比较这样比较清晰。  
>
>Q：头文件必须是.h后缀吗？  
A：不必，因为头文件只是其中的内容被#include宏命令替换，所以.txt、.doc等作为头文件的后缀都可以，但我们习惯用.h作为头文件后缀。  
>
>Q：.c文件必须包含自己的.h文件吗？为什么经常见 xx.c 里面 include 对应的 xx.h？  
A：不一定，在最初解释编译器工作原理的例子中add.c就可以不包含add.h文件，因为add.h中只是对add函数的声明，而add.c不需要这个声明也可以编译通过。
但是如果.c中的函数也需要调用同个.c中的其它函数，那么这个.c往往会include同名的.h，这样就不需要为声明和调用顺序而发愁了（C语言要求使用之前必须声明，而include同名.h一般会放在.c的开头）。有很多工程甚至把这种写法约定为代码规范，以规范出清晰的代码来。这样你可能会说：啊？那我平时只想调用 xx.c 中的某个函数，却 include了 xx.h 文件，岂不是宏替换后出现了很多无用的声明？没错，确实引入了很多垃圾，但是它却省了你不少笔墨，并且整个版面也看起来清爽的多。鱼与熊掌不可得兼，就是这个道理。反正多些声明（.h一般只用来放声明，而放不定义，参见拙著"过马路，左右看"）也无害处，又不会影响编译，何乐而不为呢？  
>
>Q：如果 a.c 中不写#include "a.h"，那么编译器是不是会自动把.h 文件里面的东西跟同名的.c 文件绑定在一起？  
A：不会

## .h与.c分离的原因
　　为何一定要分成头文件与C文件呢？又为何一般都在头件中进行函数，变量声明，宏声明，结构体声明呢？而在C文件中去进行变量定义，函数实现呢？  
　　**原因如下：**  
　　1.  如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错   
　　2. 如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入 BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间  
　　3. 头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。  
如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成了你不可想象的了，如果把这些公共的东西放在一个头文件中，想用它的C文件就只需要引用一个就OK了！这样岂不方便，要改某个声明的时候，只需要动一下头文件就行了。  
　　4. 通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。

## 头文件如何来关联源文件  
　　这个问题实际上是说，如果我想在"c.cpp"中使用"a.h"中声明的这些在"b.cpp"中实现的函数,c.cpp是怎样找到b.cpp中的实现呢？  
>"a.h"声明了一系列函数(仅有函数原型,没有函数实现)  
"b.cpp"中实现了这些函数（#include "a.h"）  
"c.cpp"中使用了这些函数（#include "a.h"）  

　　程序编译的时候，并不会去找b.cpp文件中的函数实现，只有在link的时候才进行这个工作。我们在b.cpp或c.cpp中用#include "a.h"实际上是引入相关声明，使得编译可以通过，程序并不关心实现是在哪里，是怎么实现的。源文件编译后成生了目标文件（.o或.obj文件），目标文件中，这些函数和变量就视作一个个符号。在link的时候，需要在makefile里面说明需要连接哪个.o或.obj文件（在这里是b.cpp生成的.o或.obj文件），此时，连接器会去这个.o或.obj文件中找在b.cpp中实现的函数，再把他们build到makefile中指定的那个可以执行文件中。  
　　在VC中，一帮情况下不需要自己写makefile，只需要将需要的文件都包括在project中，VC会自动帮你把makefile写好。  
　　通常，编译器会在每个.o或.obj文件中都去找一下所需要的符号，而不是只在某个文件中找或者说找到一个就不找了。因此，如果在几个不同文件中实现了同一个函数，或者定义了同一个全局变量，链接的时候就会提示"redefined"。  

## Reference
- [C语言中.h和.c文件解析（很精彩）](https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html)  
- [C语言编译器工作原理以及.h和.c文件解析](https://ain-crad.github.io/2018/12/02/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A-h%E5%92%8C-c%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/)  
