---
title: "原码、反码、补码的原理以及大小比较"
description: 
date: 2023-10-30 10:00:00 +0800
categories: [Code, Common]
tags: [Code, Common]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

## 无符号数如何比较大小
在计算机内部，无符号数和其它类型一样，都是统一按照补码加减法规则计算的（毕竟所有的数都是按照补码存放的）而唯一不同的是，最后对结果的解释方式不同。

如果无符号数相减`小于0` ，则最高位为1，但因为解释为无符号数，最高位不解释为符号位，因此，`<0`的结果被解释为该数大于`0x7FFF...FFFF`

## 补码
补码的存在是为了变减法为加法，使用补码，可以将符号位和其它位统一处理，简化计算过程，即硬件的设计难度。

“反码加一”只是补码所具有的一个性质，不能被定义成补码。负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码。
```
0111 7原
1111 -7原
1000 -7反
1001 -7补
(7原/反/补) + (-7反) = 1111(-0反)
(7原/反/补) + (-7补) = 0111 + 1001 = 1 0000 = 0000(0补)
```

在补码体系里没有符号位一说，虽然最高位为一的恰好是负数，但在补码体系里它不是符号位，而是正常数据的一部分。

>《深入理解计算机系统（原书第3版）》  
在补码格式中，0只有一种表示方式，不存在+0与-0之分！只有在原码格式或反码格式中，0才有两种表示方式，才需要区分+0与-0！

[# 8位有符号数的取值范围下限为什么是-128](https://zhuanlan.zhihu.com/p/372600243)  
>补码求解方式：先取绝对值，然后各位按位求反，最后加1。  
我们来算算-128的补码是多少？  
先取绝对值128，按位求反, 再加1  
1000 0000  
0111 1111  
1000 0000  
所以8位有符号数的取值范围下限是-128。

当理解反码时，建议不使用“**原码除符号位外，按位取反**”这一概念，而是使用“**负数绝对值的原码按位取反**”这一概念，否则不易理解对于8位无符号数，-128的补码为什么是`0x1000 0000`这一理由。

### 原理
[# 原码、反码、补码——详细解释了补码的产生和原理](https://blog.csdn.net/Turnhead/article/details/90902407)   

#### 原码  
原码是最简单也是最直观的从10进制到二进制的编码格式，人为规定原码的最高位为符号位，正数为0，负数为1，其余所有位为10进制数的绝对值。  
原码的优点是编码格式对人很友好，类似十进制中的正负号，原码用最高位0和1分别代码正负数，很直观的表示了正负数。但是原码也有一个很大的缺点，就是无法将减法转换成加法运算，如：  
```
4 - 2 （10进制）
= 4 + （-2）
= 0 100 + 1 010 （二进制原码） 
= 1110 （二进制原码）= -6 （10进制）
```
上面例子计算4-2，将4-2转换成4+(-2)并用原码计算，得出的结果错误，原码虽然很直观转换了10进制数，但是计算输出的原码值并不正确，所以计算机不能直接使用原码存储和计算。  
#### 反码  
反码的出现，主要是为了解决原码无法执行减法运算的问题，人为规定反码最高位为符号位，正数为0，负数为1，反码正数与原码正数格式一致，反码负数为负数绝对值的原码按位分别取反。  
反码的负数编码格式不像原码那样直观，但是却可以将减法转换成加法了，反码减法规则为：A - B = A + （-B），如果最高位发生了溢位，则需要在最低位加上1，如下面两个例子：  
```
（1）
    4 - 2 （10进制）
    = 4 + （-2）
    = 0100 + 1010 （二进制原码） 
    = 0100 + 1101 （二进制反码） 
    = 1 0001 （二进制反码，发生了溢位）
    = 0001 + 0001（最低位加1） 
    = 0010 （二进制反码）
    = 2（10进制）

（2）
    2 - 2 （10进制）
    = 2 + （-2）
    = 0010 + 1101 （二进制反码） 
    = 1111 （二进制反码）
    = - 0 （10进制）
```
运用反码减法规则，得到的上面两个例子的减法结果是正确的，所以计算机是可以使用反码存储和计算的，早期的计算机如CDC 6000、LINC、PDP-1等都是使用反码的，但是反码也有两个缺点：1）0有两种编码，+0 （0000）和 -0 （1111），在判断0时，需要分别判断0000和1111；2）反码减法的算法规则比较复杂，需要增加计算机内部逻辑组件额外判断溢位，会影响计算效率。  
#### 补码  
补码是现代计算机使用的编码格式，解决了上面反码的两个缺点。正数的补码与原码格式相同，负数的补码是将负数绝对值的原码分别按位取反，并加1。  
补码的减法规则比较简单，按照最简单的转换公式A-B = A + (-B) ，当减去一个数时直接转换成加上被减数的负数即可，不用像反码那样额外处理溢位，如下面两个例子：
```
（1）
    4 - 2 （10进制）
    = 4 + （-2）
    = 0100 + 1110 （二进制补码） 
    = 1 0010 （二进制补码，发生了溢位，直接丢弃溢位）
    = 0010（二进制补码） 
    = 2（10进制）

（2）
    2 - 2 （10进制）
    = 2 + （-2）
    = 0010 + 1110 （二进制补码） 
    = 1 0000（二进制补码，发生了溢位，直接丢弃溢位）
    = 0000 （二进制补码） 
    = 0（10进制）
```
使用了补码的加法，上面两个例子得出的结果都是正确的，相对于反码，补码加法更简单，直接丢弃溢位，不需要针对溢位单独处理，所以用补码做运算效率高。虽然补码运算过程很简单，但是转换和运算规则却很难理解，要弄明白其中的原理，就需要揭开补码背后的数学奥秘。
#### 补码的数学奥义  
[# 计算机补码运算背后的数学原理是什么](https://www.zhihu.com/question/30395946)  

减运算有两种运算方式，一种是普通算术加减法，通常生活中使用的是10进制普通算术加减法；另一种是模N加减法，计算机补码执行加减运算，则是使用了模N加减法。

如果当前时间为凌晨1点，要知道5个小时之后的时间是多少，只需要顺时针旋转5格，指向了6点，即为1+5的结果；如果想知道5个小时之前的时间是多少，需要逆时针旋转5格，指向晚上8点，即为1-5的结果。时钟顺时针相当于时间向前走，逆时针相当于时间往后走，但是时钟不会指向无穷大的数，当转过24个小时（24小时制）又回到了原点。在时钟转动中，1-5的最终结果为晚上8点，逆时针旋转5个小时就可以得到正确结果，同时也可以顺时钟旋转19个小时（24-5，24小时制），两种方式旋转都最终指向了晚上8点。所以任意逆时针旋转得到的结果都能通过顺时钟旋转得到，当逆时针旋转N个小时，与顺时针旋转24-N小时相等，24又称为模，如果把顺时针看成是加法，逆时针看成是减法，那么时钟旋转可以看成模24的加减法运算，满足公式**A - m = A + (24 - m)** ，即在时钟任一时刻A点，从A点逆时针旋转m个小时得到的结果，与从A点顺时针旋转24-m得到的结果一致。模N运算将减法转换成了加法。

计算机使用的二进制位数是有限制的，比如4位，8位，16位，64位等等，当数值太大超过最大位数时，会发生溢出，重新归0，所以计算机的二进制能表示的数不是无穷大的，由于溢出归零的特点，更像时钟旋转。

在时钟运算中，将顺时针看成加法，逆时针看成减法，那么时钟运算可以看成是模24的加减法，同理四位二进制也可以看成是模N的加减法，在4位二进制中，转一圈为2^4=16，所以4位二进制的加减法为模16的加减法，减法很容易的就被转换成了加法，即满足模N加减法公式：A - m=A +（16 - m）。

虽然根据模N加减法实现了加减法转换，但此时又有新的问题，4位二进制只有1和0，是没有区分正负数的，而人们在计算的时候是要区分正负数的，所以需要人为将部分二进制划分为负数，另一部分划分为正数，根据模N加减法公式A-m=A+（16-m），当A为零点时，根据模N加减法公式得到 0-m=0+16-m，即-m=16-m，即将零点A逆时针移动m得到负数m，同时这个负数m也可以从零点A顺时针移动16-m得到，零点A可以为上面四位二进制任意一位，比如定义0000或者0001为零点都是可以的，但是为了简单运算，人为规定0000为零点，0000逆时针方向的为负数，顺时针方向的为正数。如在0000逆时针旋转1个数或者顺时针旋转16-1得到1111，那么1111代表-1，相应的顺时针移动一个数为+1，即用0001表示+1；同理在0000逆时针旋转2个数或者顺时针旋转16-2得到1110，那么1110代表-2，相应的顺时针移动两个数为+2，即用0010表示+2；同理1101和0011分别为-3和+3，1100和0100分别为-4和+4，1011和0101分别为-5和+5，1010和0110分别为-6和+6，1001和0111分别为-7和+7，但是1000比较特殊，0000逆时针旋转8个数得到1000，所以1000为-8，相应的顺时针旋转8个数也得到了1000，1000既能表示-8又能表示+8，为了不产生冲突，人为规定1000为-8。如下图：  
![输入图片说明](/imgs/code-binary-encode/2023-10-31/6tOJCy2d4IcrK0rR.png)

上图中的四位二进制根据模N加减法划分出了正负数，同理对任意n位二进制，模 N 等于=$2^n$ ，根据上面的模N加减法公式得到$-m = N - m = 2^n - m = (2^n - 1) + 1 - m$，最终得到了负数推导公式：$-m =(2^n - 1)  -m + 1$，其中$（2^n -1）-m$为负数的原码绝对值按位取反，即为反码，再加上1则可以快速得到一种负数编码，这种负数编码就称为补码。补码负数范围转换成10进制为 $-1 \sim -2^{n-1}$，正数范围转换成10进制为 $1 \sim 2^{n-1}-1$，再加上0，因此补码转换成10进制的范围为$-2^{n-1} \sim 2^{n-1}-1$。

要想弄清楚补码，必须要弄清楚补码要解决的问题，计算机是二进制的，无法直接表示正负数，另外在计算机内部直接实现减法，也会影响计算机效率，所以人们希望要找到一种既能使用二进制表示10进制正负数的编码格式，同时这种编码格式又能满足将减法转换成加法进行运算，同时满足这两个条件有反码和补码，但由于反码中的0有两个编码格式，另外反码加法运算也比较复杂，慢慢地反码被淘汰了。补码刚好解决了反码的两个缺点，所以补码成了现代计算机的通用编码。
