---
title: "分散加载文件"
description: 
date: 2023-11-27 10:00:00 +0800
categories: [MDK]
tags: [MDK]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

## 分散加载文件
### 基本概念
有时候用户希望将不同代码放在不同存储空间，也就是通过编译器生成的映像文件需要包含多个域，每个域在加载和运行时可以有不同的地址。

要生成这样的映像文件，必须通过某种方式告知编译器相关的地址映射关系。在Keil/ADS/IAR等编译工具中，可通过分散加载机制实现。

```
ROM（Flash）Size = Code＋RO-Data＋RW-Data = 0.76KB
RAM Size = RW-Data＋ZI-Data = 2.01KB
```
为什么RW-Data既占用Flash又占用RAM，变量不是放在RAM中的么，为什么会占用Flash？因为RW数据不能像ZI那样“无中生有”的，ZI段数据只要求其所在的区域全部初始化为零，所以只需要程序根据编译器给出的ZI基址及大小来将相应的RAM清零。但RW段数据却不这样做，所以编译器为了完成所有RW段数据赋值，其先将RW段的所有初值，先保存到Flash中，程序执行时，再Flash中的数据搬运到RAM中，所以RW段即占用Flash又占用RAM，且占用的空间大小是相等的。  
![输入图片说明](/imgs/mdk-scatter/2023-11-27/he1KvmgNyvn7cVqq.png)

这里有必要再了解一下，ZI和RW段数据的赋值在工程中是在什么地方实现的？

首先，变量必先要初始化才能使用，否则初值不正确，而在main()函数后变量已经可以正常使用，那就是说变量的初始化是在之前完成的，查看这之前的代码只有`__main()`一个函数，除了赋初值外，都还做了什么呢？  
`__main()`这个函数主要由以下两部分功能组成，如下所示。  
- `_main()`：  
完成代码和数据的拷贝，并把ZI数据区清零。代码拷贝可将代码拷贝到另外一个映射空间并执行，如将代码拷贝到RAM执行；数据拷贝完成RW段数据赋值；数据区清零完成ZI段数据赋值。以上的代码和分散加载文件密切相关。  
-  `_rt_entry()`：  
进行STACK和HEAP等的初始化。最后`_rt_entry`跳进main()函数入口。当main()函数执行完后，`_rt_entry`又将控制权交还给调试器。  

### 分散加载文件概述
分散加载（scatter）文件是一个文本文件，它可以用来描述连接器生成映像文件时需要的信息。通过编写一个分散加载文件来指定ARM连接器在生成映像文件时如何分配Code、RO-Data，RW-Data，ZI-Data等数据的存放地址。

1. 何时使用分散加载
链接器的命令行选项提供了一些对数据和代码位置的控制，但要对位置进行全面控制，则需要使用比命令行中的输入内容更详细的指令。需要或最好使用分散加载描述的情况包括：
2. 复杂内存映射
如果必须将代码和数据放在多个不同的内存区域中，则需要使用详细指令指定将哪些数据放在哪个内存空间中。
3. 不同类型的内存
许多系统都包含多种不同的物理内存设备，如闪存、ROM、SDRAM和快速SRAM。分散加载描述可以将代码和数据与最适合的内存类型相匹配。例如，可以将中断代码放在快速SRAM中以缩短中断等待时间，而将不经常使用的配置信息放在较慢的闪存中。
4. 内存映射的I/O
分散加载描述可以将数据节准确放在内存映射中的某个地址，以便能够访问内存映射的外围设备。
5. 位于固定位置的函数
可以将函数放在内存中的固定位置，即使已修改并重新编译周围的应用程序。
6. 使用符号标识堆和堆栈
链接应用程序时，可以为堆和堆栈位置定义一些符号。

### 具体应用及举例见pdf

## sct分散加载文件的格式与应用
当工程按默认配置构建时，MDK会根据我们选择的芯片型号，获知芯片的内部FLASH及内部SRAM存储器概况，生成一个以工程名命名的后缀为*.sct的分散加载文件(Linker Control File，scatter loading)，链接器根据该文件的配置分配各个节区地址，生成分散加载代码，因此我们通过修改该文件可以定制具体节区的存储位置。

例如可以设置源文件中定义的所有变量自动按地址分配到外部SRAM，这样就不需要再使用关键字`__attribute__`按具体地址来指定了；利用它还可以控制代码的加载区与执行区的位置，例如可以把程序代码存储到单位容量价格便宜的NAND-FLASH中，但在NAND-FLASH中的代码是不能像内部FLASH的代码那样直接提供给内核运行的，这时可通过修改分散加载文件，把代码加载区设定为NAND-FLASH的程序位置，而程序的执行区设定为SRAM中的位置，这样链接器就会生成一个配套的分散加载代码，该代码会把NAND-FLASH中的代码加载到SRAM中，内核再从SRAM中运行主体代码，大部分运行Linux系统的代码都是这样加载的。

在认识语法之前，让我们先了解两个概念，即 加载地址 & 运行地址。 ARM 映象文件各组成部分在存储系统中的地址有两种：一种是在映象文件位于存储器中时（也就是该映象文件开始运行之前，通俗的说就是下载到 Flash 中的二进制代码）的地址，称为加载地址；一种是在映象文件运行时（通俗的说就是给板子上电，开始运行 Flash 中的程序了）的地址，称为运行时地址。赋初值的全局变量和静态变量在程序还没运行的时候，初值是被放在 Flash 中的，此时它们的地址称为加载地址，当程序运行后，这些初值会从 Flash 中拷贝到 RAM 中，这时的地址就是运行地址。

好了，现在我们来看看分散加载的基本语法。分散文件包含一个或多个加载区域，每个加载区域可以包含一个或多个执行区域。顾名思义，加载域就是程序运行之前代码或数据存储的地方，运行域就是程序运行时，读写变量数据的地方。

sct文件中主要包含描述加载域及执行域的部分，同等级的域之间使用花括号“{}”分隔开，最外层的是加载域，第二层“{}”内的是执行域。  
![分散加载文件的整体结构](/imgs/mdk-scatter/2023-11-27/mUwBEW6wS9ScDYql.png)

MDK默认使用的sct文件:
```
; *************************************************************
; *** Scatter-Loading Description File generated by uVision ***
; *************************************************************

LR_IROM1 0x08000000 0x00100000  {   ; 加载域，基地址 空间大小
	ER_IROM1 0x08000000 0x00100000  {   ; 加载地址 = 执行地址
	   *.o (RESET, +First)
	   *(InRoot$$Sections)
	   .ANY (+RO)
	}
	RW_IRAM1 0x20000000 0x00020000  {  ; 可读写数据
	   .ANY (+RW +ZI)
	}
}
```
在默认的sct文件配置中仅分配了Code、RO-data、RW-data及ZI-data这些大区域的地址，链接时各个节区(函数、变量等)直接根据属性排列到具体的地址空间。

```
加载域名  起始地址 大小{；加载区域大小 （分号后面是注释）
        运行域名 起始地址 大小   ；执行地址
        {
                中断向量表起始地址， +First表示强制放到首地址

                ARM相关库，InRoot$$Sections即ARM库的链接器标号，主要作用COPY RW区到RAM，然后在RW区后面创建ZI区。 库函数__main函数中有这个段。 它是__main()的一部分。

                编译文件RO只读在该区域
        }
        运行内存名字 起始地址 大小
        {
                编译可读可写，静态区
        }
}
```

### 加载域
加载域格式：
```
//方括号中的为选填内容
加载域名 (基地址 | ("+" 地址偏移)) [属性列表] [最大容量]
"{"
   执行区域描述+
"}"
```
-   加载域名：名称，在map文件中的描述会使用该名称来标识空间。如本例中只有一个加载域，该域名为LR_IROM1。
-   基地址+地址偏移：这部分说明了本加载域的基地址，可以使用+号连接一个地址偏移，算进基地址中， 整个加载域以它们的结果为基地址。如本例中的加载域基地址为0x08000000，刚好是STM32内部FLASH的基地址。
-   属性列表：属性列表说明了加载域的是否为绝对地址、N字节对齐等属性，该配置是可选的。本例中没有描述加载域的属性。
-   最大容量：最大容量说明了这个加载域可使用的最大空间，该配置也是可选的，如果加上这个配置后， 当链接器发现工程要分配到该区域的空间比容量还大，它会在工程构建过程给出提示。本例中的加载域最大容量为0x00100000，即1MB，正是本型号STM32内部FLASH的空间大小。

### 执行域
执行域格式：
```
//方括号中的为选填内容
执行域名 (基地址 | "+" 地址偏移) [属性列表] [最大容量 ]
"{"
   输入节区描述
"}"
```
执行域的格式与加载域是类似的，区别只是输入节区的描述有所不同。在例子中包含了ER_IROM1及RW_IRAM两个执行域，它们分别对应描述了STM32的 内部FLASH及内部SRAM的基地址及空间大小。而它们内部的“输入节区描述”说明了哪些节区要存储到这些空间，链接器会根据它来处理编排这些节区。

### 输入节区描述
配合加载域及执行域的配置，在相应的域配置“输入节区描述”即可控制该节区存储到域中
输入节区描述的几种格式：
```
//除模块选择样式部分外，其余部分都可选选填
模块选择样式"("输入节区样式",""+"输入节区属性")"
模块选择样式"("输入节区样式",""+"节区特性")"

模块选择样式"("输入符号样式",""+"节区特性")"
模块选择样式"("输入符号样式",""+"输入节区属性")"
```
-   模块选择样式：模块选择样式可用于选择o及lib目标文件作为输入节区，它可以直接使用目标文件名或`*`通配符， 也可以使用`.ANY`。例如，使用语句`bsp_led.o`可以选择bsp_led.o文件，使用语句`.o`可以选择所有o文件，使用`.lib`可以选择所有lib文件，使用`*`或`.ANY`可以选择所有的o文件及lib文件。其中`.ANY`选择语句的优先级是最低的，所有其它选择语句选择完剩下的数据才会被`.ANY`语句选中。
    
-   输入节区样式：我们知道在目标文件中会包含多个节区或符号，**通过输入节区样式可以选择要控制的节区**。 示例文件中`(RESET，+First)`语句的RESET就是输入节区样式，它选择了名为RESET的节区，并使用后面介绍的节区特性控制字`+First`表示它要存储到本区域的第一个地址。示例文件中的`(InRoot$$Sections)`是一个链接器支持的特殊选择符号，它可以选择所有HAL库里要求存储到root区域的节区，如`__main.o`、`__scatter_.o`等内容。
    
-   输入符号样式：同样地，使用输入符号样式可以选择要控制的符号，符号样式需要使用`:gdef:`来修饰。 例如可以使用`(:gdef:Value_Test)`来控制选择符号`Value_Test`。
    
-   输入节区属性：通过在模块选择样式后面加入输入节区属性，可以选择样式中不同的内容，每个节区属性描述符前要写一个`+`号， 使用空格或`，`号分隔开，可以使用的节区属性描述符见表40‑6。  
![输入图片说明](/imgs/mdk-scatter/2023-11-27/eCGE9UqUGc1HXcof.png)

例如，示例文件中使用`.ANY(+RO)`选择剩余所有节区RO属性的内容都分配到执行域ER_IROM1中，使用`.ANY(+RW +ZI)`选择剩余所有节区RW及ZI属性的内容都分配到执行域RW_IRAM1中。

节区特性：节区特性可以使用`+FIRST`或`+LAST`选项配置它要存储到的位置，FIRST存储到区域的头部，LAST存储到尾部。 通常重要的节区会放在头部，而CheckSum(校验和)之类的数据会放在尾部。

例如示例文件中使用`(RESET,+First)`选择了RESET节区，并要求把它放置到本区域第一个位置，而RESET是工程启动代码中定义的向量表，见 代码清单40_19，该向量表中定义的堆栈顶和复位向量指针必须要存储在内部FLASH的前两个地址，这样STM32才能正常启动，所以必须使用FIRST控制它们存储到首地址。 

总的来说，我们的sct示例文件配置如下：程序的加载域为内部FLASH的0x08000000，最大空间为0x00100000；程序的执行基地址与加载基地址相同，其中RESET节区定义的向量表要存储在内部FLASH的首地址，且所有o文件及lib文件的RO属性内容都存储在内部FLASH中；程序执行时RW及ZI区域都存储在以0x20000000为基地址，大小为0x00020000的空间(128KB)，这部分正好是STM32内部主SRAM的大小。

链接器根据sct文件链接，链接后各个节区、符号的具体地址信息可以在map文件中查看。

### 控制文件分配到指定的存储空间
设定好存储器的信息后，可以控制各个源文件定制到哪个部分存储器，在MDK的工程文件栏中，选中要配置的文件，右键，并在弹出的菜单中选择“Options for File xxxx”即可弹出一个文件配置对话框，在该对话框中进行存储器定制  
![输入图片说明](/imgs/mdk-scatter/2023-11-27/0cEhSu2UDq1vsiAa.png)

在弹出的对话框中有一个“Memory Assignment”区域(存储器分配)，在该区域中可以针对文件的各种属性内容进行分配，如Code/Const内容(RO)、Zero Initialized Data内容(ZI-data)以及Other Data内容(RW-data)，点击下拉菜单可以找到在前面Target页面配置的IROM1、IRAM1、IRAM2等存储器。

例如图中我们把这个bsp_led.c文件的Other Data属性的内容分配到了IRAM2存储器(在Target标签页中我们勾选了IRAM1及IRAM2)，当在bsp_led.c文件定义了一些RW-data内容时(如初值非0的全局变量)， 该变量将会被分配到IRAM2空间，配置完成后点击OK，然后编译工程，查看到的sct文件内容如下：
```
LR_IROM1 0x08000000 0x00100000  {    ; load region size_region
	ER_IROM1 0x08000000 0x00100000  {  ; load address = execution address
	   *.o (RESET, +First)
	   *(InRoot$$Sections)
	   .ANY (+RO)
	}
	RW_IRAM1 0x20000000 0x00020000  {  ; RW data
	   .ANY (+RW +ZI)
	}
	RW_IRAM2 0x10000000 0x00010000  {
	   bsp_led.o (+RW)
	   .ANY (+RW +ZI)
	}
}
```
虽然MDK的这些存储器配置选项很方便，但有很多高级的配置还是需要手动编写sct文件实现的，例如MDK选项中的内部ROM选项最多只可以填充两个选项位置，若想把内部ROM分成多片地址管理就无法实现了；另外MDK配置可控的最小粒度为文件，若想控制特定的节区也需要直接编辑sct文件。

## 补充关于`__attribute__`关键字的说明
在程序中，当需要指定某个变量的内存地址时，MDK提供了一个关键字`__attribute__`实现该功能， 这种用法通常也是为了把变量指定到外部扩展的存储器， 而sct文件存储器管理取代或改进了这种地址分配方式。在此处先补充一下关键字`__attribute__`的使用说明。

直接指定变量地址：
```
/*定义一个要指定的地址*/
#define USER_ADDR ((uint32_t)0x20005000)

/*使用atribute指定该变量存储到USER_ADDR,这种方式必须定义成全局变量*/
uint8_t testValue __attribute__((at(USER_ADDR)));

testValue = 0xDD;
```
这种方式使用`__attribute__((at()))`来指定变量的地址，代码中指定testValue存储到USER_ADDR地址0x20005000中，若把该地址改为外部存储器SRAM的地址，变量就会被存储到外部SRAM了，因而利用该关键字在一定程度上可以定制各种存储器的空间分配。要注意使用这种方法定义变量时，必须在函数外把它定义成全局变量，才可以存储到指定地址上。

然而，当有多个这样的变量时，为了防止变量占用的空间重叠，或减少碎片空间进行充分利用，就需要手动计算各个变量的地址了，非常麻烦。在本实验中我们将修改sct文件，让链接器自动分配全局变量到指定的存储区域并进行管理，使得利用指定存储区域时就跟普通的变量定义一样简单。

## Reference
- [# 周立功单片机：分散加载文件浅释](https://download.eeworld.com.cn/detail/lamaba/598151)
- [# 39.6. 通过修改分散加载文件实现定制存储空间](https://doc.embedfire.com/mcu/i.mxrt/i.mxrt1052/zh/latest/doc/chapter39/chapter39.html#id85)
- [# 39.7. Keil版本工程模板分散加载文件简述](https://doc.embedfire.com/mcu/i.mxrt/i.mxrt1052/zh/latest/doc/chapter39/chapter39.html#keil)
- [# LPC54608 之 将部分程序放入外部 Flash](https://www.wpgdadatong.com.cn/blog/detail/42712)
