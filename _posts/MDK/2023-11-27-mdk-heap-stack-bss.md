---
title: "程序文件与程序分区中的内存分布"
description: 
date: 2023-11-27 10:00:00 +0800
categories: [MDK]
tags: [MDK]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text under the image
---

## 数据存储
1. 局部变量存储在栈中  
2. 全局变量、静态变量（全局和局部静态变量）存储在静态存储区  
3. new申请的内存是在堆中  
4. 字符串常量也是存储在静态存储区  

对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。

## 堆栈、BSS段、代码段、数据段、RO、RW、ZI等概念区分

在区分一个程序的堆栈、bss、text段、RO、RW、ZI等概念时，首先区分一下程序文件和程序进程，然后了解一下哈弗结构和冯诺依曼结构。 

程序文件是编译后生成的可执行文件，比如.bin文件等；程序进程就是程序运行时的程序。这两个概念很好区分，特别强调一下，分开表达主要是怕读者在阅读过程中混淆了。

哈佛结构和冯诺依曼结构的主要区别就是处理器能不能实现取指令和取数据的并发进行。嵌入式芯片中主要是哈佛结构，PC机上是冯诺依曼结构。

**经典的哈佛结构**：  
程序存储器和数据存储器是各自独立的存储器。处理器应该有两套总线，一套是程序存储器的数据和地址总线，一套是数据存储器的数据和地址总线。取指令和取数据能并发进行。51的程序进程的逻辑代码段放在ROM中，而变量部分则放在RAM中，取ROM中的指令和RAM中的变量是两套总线。

**改进型哈佛结构**：  
程序存储器和数据存储器是各自独立的存储器。处理器只有一套总线，分时访问程序存储器和数据存储器，但是在处理器中有icache和dcache将程序和数据分开，所以处理器仍然可以并步执行取指令和取数据。从ARM9开始以后所有的ARM处理器内核都是改进型的哈佛结构。

**冯诺依曼结构**：  
没有程序存储空间和数据存储空间之分。处理器只有一套总线，取指令和取数据是不能同时进行的。程序进程全部在RAM中，他们之间一般是按照代码的执行顺序依次存储。由于全部在RAM中，运行速度快，所需的RAM多。

早期的微处理器大多采用冯诺依曼结构，典型代表是Intel公司的X86微处理器，即数据和程序储存在一起，而且pc机的RAM资源相当丰富，从几十M到几百M甚至是几个G，客观上能承受大量的程序数据；

哈佛总线技术应用以DSP和ARM为代表，单片机的片内RAM资源是相当有限的，内部的RAM过大会带来成本的大幅度提高。

**代码搬运**  
ARM-cortex-M3/4的单片机（比如STM32 MK60等）：该类单片机的代码在nor flash中，cortex内核可以直接运行，不需要将代码加载到ram中运行。

可通过配置从flash/ram启动。

大部分单片机的代码直接在nor flash中运行，少部分需要加载到ram中。nor flash可以直接寻址一个字节，可以找到一个指令的具体地址，因此可以直接运行。nand flash 的存储单元是块，不能对指令直接寻址，因此不能直接运行其中的代码。因此保存在nand flash中的程序不加载到ram中运行不了，即你硬盘中的Windows如果不加载到内存条中，运行不起来。

在RAM中执行可能会得到更好的执行性能，但是对于MCU内部的Nor Flash来说是没有必要的。有一点要提及的是，程序一般会由代码段txt，只读数据段rodata，初始化数据段data和未初始化数据段bss(并无数据)组成，只读数据段因为和代码段一样不需要改动，所以可以留在Flash当中 ，但是需要将也存储在Flash中的data段加载到RAM中以及空出空间给bss。这是运行环境的初始化。

### 程序文件中的分区
Code，RO_data，RW_data，ZI_data，RO，RW，常出现在嵌入式程序编译完成后的统计，例如MDK，IAR，ARM GCC。
>有些技术文章中会直接使用RO，请注意区分RO和RO-data的区别。

**Code**：即代码域，它指的是编译器生成的机器指令。  
**RO_data**：ReadOnly data，即只读数据域，它指程序中用到的只读数据，全局变量，例如C语言中const关键字定义的全局变量就是典型的RO-data。  
**RW_data**：ReadWrite data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。  
**ZI_data**：ZeroInitialie data，即0初始化数据，它指初始化为“0值”的可读写数据域，它与RW_data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。包括未初始化的全局变量，和初始化为0的全局变量。  
**RO**：只读区域，包括RO_data和code。

当程序存储在ROM中时，所占用的大小为**Code + RO_data + RW_data** 。  

当程序执行时， RW_data和 ZI_data在RAM中，在arm上，RO_data和code处于ROM中（其他结构x86位于RAM中）。

其中code对应text段（代码段），RO_data + RW_data对应data段（数据段），ZI_data对应BSS段。

### 程序进程中的分区
相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段( code /text)，全局静态区，文字常量区，程序代码区。  
**BSS段**：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。  
**数据段**：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。  
**代码段**：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。  
**堆（heap）**：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。  
**栈(stack)**：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。

全局静态区，文字常量区，程序代码区是从内存地址分配的角度来描述的。  
**全局区（静态区）（static）**—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。  
**文字常量区**—常量字符串就是放在这里的。  
**程序代码区**—存放函数体的二进制代码。

一般我们所说的程序在内存中的分布指的就是程序在虚拟内存中的存储方式。  （Linux下？）
**从低地址到高地址，可分为下面几段：  
预留内存地址**（操作系统维护的内存地址，不可访问）  
**text段**（只读，存代码和一些其他的东西）；  
**data段**（存初始化的全局变量和static变量，另外还有文字常量区，常量字符串就是放在这里，程序结束后由系统释放）；  
**bss段**（存未初始化的全局变量和static变量）；  
**堆**（由低地址向高地址增长，一般new和malloc分配，由程序员分配释放）；  
**共享库文件**（调用的库文件，位于堆和栈之间）；**  
**栈**（由高地址向低地址增长，和堆的增长方式相对，对不同的OS来说，栈的初始大小有规定，可以修改，目前默认一般为2M，由编译器自动分配释放）；  
**再上面存的都是操作系统和内核调用的一些内存地址**。

![输入图片说明](/imgs/mdk-heap-stack-bss/2023-11-28/0KWBrpVyKml5OlFH.png)
