---
title: "嵌入式GDB调试"
description: 
date: 2025-02-10 10:00:00 +0800
categories: [Linux]
tags: [Linux]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---
## 背景
在开发 STM32 时，我们通常会使用集成开发环境（IDE），其中已经集成了调试器，并且可以与仿真器配合使用，非常方便，如KEIL。而在 Linux 应用程序的开发中，常常直接在命令行使用 gdb 进行调试，或者可以使用 VSCode+gdb 进行调试。

## GDB 简介
    gdb 工具是 GNU 项目调试器，基于命令行。和其他的调试器一样，我们可以使用 gdb 来一行行的运行程序、单步执行、跳入/跳出函数、设置断点、查看变量等等，它是 UNIX/LINUX 操作系统下强大的程序调试工具。对于一般的Linux桌面系统(例如，ubuntu、centos等)，我们可以直接运行gdb来调试程序。但嵌入式系统中的芯片性能较弱，无法直接运行gdb调试程序。所以，嵌入式系统一般在PC端运行gdb工具，源码也放在PC端，源码对应的可执行程序放在开发板运行。那么在调试程序时，开发板如何与PC段通信呢？这需要在开发板运行gdbserver，通过网络与PC端进行通信。因此，在搭建GDB调试环境，需要我们在PC端安装gdb用具、移植gdbserver到开发板。

## 环境搭建

[# gdb源码](https://www.sourceware.org/gdb/download/)



[# gdb编译教程（支持linux下X86和ARM架构）](https://blog.csdn.net/weixin_43246170/article/details/143707599)


嵌入式平台中使用 GDB 时会用到 GDB 的远程 (remote) 调试模式：在目标板上通过 gdbserver 运行待调试的程序，在宿主机上运行 gdb 并通过 'target remote [ip]:[port]' 来连接到目标板上的 gdbserver，从而启动远程调试。各种调试命令在宿主机上输入，程序执行效果(包括打印)在目标板上展示，这很容易理解，因为正在调试的程序本来就是在目标板上运行的。不在目标板上直接运行 gdb 进行调试是因为目标板硬件配置低，跑不动 gdb，当然，不排除某些嵌入式平台的性能很强劲，能够正常运行 gdb。


## 远程调试
注意：待调试程序中编译时要使用`-g`选项，否则不会附带调试信息；调试时需要关闭编译优化，否则影响代码调试。

|gcc优化等级|说明|
|--|--|
|-O0|最少的优化（默认的编译选项），可以最大程度上配合产生代码调试信息，可以在任何代码行打断点|
|-O 或 -O1|有限优化，编译时占用稍微多的时间和相当大的内存，减少代码生成尺寸、缩短执行时间，去除无用的 inline 和无用的 static 函数、死代码消除等，在影响到调试信息的地方|均不进行优化，在适当的代码体积和充分的调试之间平衡，代码编写阶段最常用的优化等级
|-O2|高度优化，在 -O1 的基础上，采用几乎所有的目标配置支持的优化算法，用以提高目标代码的运行速度，但会牺牲部分编译速度，调试信息不友好，有可能会修改代码和函数调用执行流程|
|-O3|最大程度优化，在 -O2 的基础上，采取很多向量化算法，提高代码的并行执行程度，利用现代CPU中的流水线，Cache等，目标：拼命提高运行速度，那怕增加目标代码的大小|
|-Os|相当于 -O2.5，在-O2的基础之上，尽量的降低目标代码的大小|

### target(目标机)
1. ps查看需要调试的进程PID
2. `gdbserver  --attach :3333   265`
>3333是指定端口号 265是需要调试的进程PID
```
Attached; pid = 265
Listening on port 3333
```
>This gdbserver was configured as "arm-linux-gnueabihf"
3. 连接远程成功
```
Remote debugging from host 192.168.2.101
```
4. 远程结束
```
Detaching from process 265
```

### host（宿主机）
1. arm-linux-gnueabihf-gdb
>This GDB was configured as "--host=x86_64-unknown-linux-gnu --target=arm-linux-gnueabihf".
2. `target remote 192.168.2.100:3333`
3. 调试工作
4. 调试结束后输入q结束，target上会随之Detach

### 注意事项
1.  在x86_linux下调试嵌入式linux中的程序时，需要使用经过交叉编译的gdb（--host=x86_64-unknown-linux-gnu --target=arm-linux-gnueabihf），并通过嵌入式linux中运行的gdbserver进行中转。 


## vscode + gdb

### 环境介绍
- windows主机
    使用vscode + Remote-SSH 打开存放在Ubuntu的源代码
    使用vscode + Remote Development 进行远程调试

- VM虚拟Ubuntu
    源代码目录，程序经过交叉编译后，需在开发板arm运行（**注意：需要关闭编译优化**）
    由windows主机的vscode + Remote Development调用gdb

- 开发板arm 
    通过nfs与Ubuntu共享文件目录，通过gdbserver支持远程调试

### vscode
1. 安装Remote Development
2. 在运行与调试功能增加配置文件launch.json
根据实际环境修改json文件中的相关配置：  
>- name：调试的项目名  
>- program：需要调试的应用程序可执行文件路径。  
>- cwd：需要调试的应用程序源码路径。  
>- miDebuggerPath：此项需要手动添加，用于指定所使用的交叉编译器gdb路-  
>- miDebuggerServerAddress：此项需要手动添加，远程 gdbserver服务器地-也就是开发板地址  
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) program_name",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/program_name",
            "args": [],
            "stopAtEntry": true,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "为 gdb 启用整齐打印",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "将反汇编风格设置为 Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ],
            "miDebuggerPath":"/home/han/nfs_dir/arm-linux-gnueabihf-gdb",
            "miDebuggerServerAddress":"192.168.2.100:3333"
        },
    ]
}
```

### target(目标机)
`gdbserver :3333 /${dir}/debug_program`  
>可以只指定端口号


## coredump-调试执行异常崩溃的程序
在Linux操作系统中，当程序执行发生异常崩溃时，系统可以将发生崩溃时的内存数据、调用堆栈情况等信息自动记录下载，并存储到一个文件中，该文件通常称为core 文件，Linux 系统所具备的这种功能又称为核心转储（core dump）。幸运的是，GDB 对core 文件的分析和调试提供有非常强大的功能支持，当程序发生异常崩溃时，通过GDB 调试产生的 core文件，往往可以更快速的解决问题。
