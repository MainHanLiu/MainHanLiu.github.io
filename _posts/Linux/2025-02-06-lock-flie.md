---
title: "使用文件锁方式保证进程的唯一性"
description: 
date: 2025-02-06 10:00:00 +0800
categories: [Linux]
tags: [Linux]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text upder the image
---

## 使用文件锁方式保证进程的唯一性
```c
int lock_file(int fd)
{
    struct flock lock;
    lock.l_type = F_WRLCK;  // 申请写锁
    lock.l_whence = SEEK_SET;
    lock.l_start = 0;
    lock.l_len = 0;  // 锁整个文件
    return fcntl(fd, F_SETLK, &lock);
}
```
进程崩溃（异常退出）后，锁会自动释放，因此新的进程可以成功加锁。意味着：如果上一个进程崩溃，新的进程可以继续运行。
（虽然锁会自动释放，但/tmp/south_dev.pid文件仍然存在。）


如果 不检查旧的 PID 直接清空锁文件，可能会导致多个相同进程同时运行，从而引发竞争条件（race condition）或资源冲突。

 1. 进程已运行，但新进程仍启动
如果不检查 PID，进程异常退出时：
旧进程仍然存活（但可能卡住或部分崩溃）。
新进程启动，清空 SOUTH_DEV_LOCK_FNAME，写入自己的 PID。
这样，两个进程都会运行，可能导致：
文件或端口占用冲突（如日志、数据库、网络端口）。
重复任务执行（如两个进程同时修改同一文件）。
资源争夺（CPU、内存）。
锁无意义（两个进程都认为自己是唯一的）。

2. 进程正在正常关闭，但新进程误以为它已退出
假设旧进程正在关闭，但还未完全退出。
新进程直接清空文件，并覆盖 PID。
结果：
旧进程仍然持有资源（例如，数据库连接、socket）。
新进程误以为自己是唯一的进程，可能导致：
数据库死锁（两个进程尝试写入相同的数据）。
日志文件冲突（两个进程写入同一日志文件）。
设备访问异常（两个进程同时写入串口、GPIO）。

3. 竞争条件（Race Condition）
如果两个进程几乎同时启动：
进程 A 打开 SOUTH_DEV_LOCK_FNAME 并准备写入自己的 PID。
进程 B 也打开 SOUTH_DEV_LOCK_FNAME，但 A 还没完成写入。
A 写入自己的 PID，但 B 马上清空，并写入自己的 PID。
最终，A 认为自己是唯一的进程，B 也认为自己是唯一的进程。
这会导致两个进程同时运行！

如果该锁文件只有一个进程会尝试使用，那么可以在加锁成功后直接清除pid并写入当前进程的pid，不会引发多进程的竞争问题。如果有不同的线程在尝试对同一个文件加锁，那么加锁成功后还需要判断原有进程是否存活，如果存活（可能卡住或部分崩溃），则不允许新进程启动。

>假设只有一个进程会访问这个文件，那么：
1. 如果进程崩溃，锁会自动释放（flock 或 fcntl）。
2. 新进程启动时，会重新获取锁，然后清空文件。
3. 不会有多个进程同时运行，因为只有这个进程会使用锁文件。

但有个例外情况:如果进程是 SIGKILL（kill -9）被强制终止：
进程可能来不及释放资源，导致文件仍然存在，但锁已释放。
如果新进程立刻启动，可能会误认为旧进程已退出，而实际上它仍然在释放资源。

如果要更安全，仍然建议加上 kill(old_pid, 0) 检查，即使只有一个进程使用它。
