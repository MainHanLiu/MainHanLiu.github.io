---
title: "SQLite Note"
description: 
date: 2025-01-02 10:00:00 +0800
categories: [Linux]
tags: [Linux, SQLite, Note]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text under the image
---

[SQLite 主页 SQLite中文网](https://sqlite.readdevdocs.com/)

## 关于 SQLite
SQLite 是一个进程内库，它实现了一个 独立的、 无服务器的、 零配置的、 事务性的 SQL 数据库引擎。SQLite 的代码属于 公共领域，因此可以免费用于任何目的，无论是商业用途还是私人用途。SQLite 是世界上部署最广泛的数据库，其应用程序多得我们数不过来，其中包括几个备受瞩目的项目。

SQLite 是一个嵌入式 SQL 数据库引擎。与大多数其他 SQL 数据库不同，SQLite 没有单独的服务器进程。SQLite 直接读写普通磁盘文件。具有多个表、索引、触发器和视图的完整 SQL 数据库包含在单个磁盘文件中。数据库文件格式是跨平台的——您可以在 32 位和 64 位系统之间或 大端和 小端 架构之间自由复制数据库。

SQLite 是一个紧凑的库。启用所有功能后，库大小可以小于 750KiB，具体取决于目标平台和编译器优化设置。（64 位代码更大。一些编译器优化，如激进的函数内联和循环展开，可能导致目标代码更大。）内存使用和速度之间存在权衡。SQLite 通常运行得越快，你给它的内存越多。尽管如此，即使在低内存环境中，性能通常也相当不错。根据使用方式，SQLite 可能 比直接文件系统 I/O 更快。

SQLite 不能直接与客户端/服务器 SQL 数据库引擎（如 MySQL、Oracle、PostgreSQL 或 SQL Server）相比较，因为 SQLite 试图解决不同的问题。

客户端/服务器 SQL 数据库引擎努力实现企业数据的共享存储库。他们强调可扩展性、并发性、集中化和控制。SQLite 致力于为单个应用程序和设备提供本地数据存储。SQLite 强调经济、效率、可靠性、独立性和简单性。

SQLite 不与客户端/服务器数据库竞争。SQLite 与fopen()竞争。

## SQLite是嵌入式的，不是客户端-服务器
每当将 SQLite 与其他 SQL 数据库引擎（如 SQL Server、PostgreSQL、MySQL 或 Oracle）进行比较时，首先要认识到 SQLite 并不是要替代或竞争任何这些系统，这一点很重要。SQLite 是无服务器的。没有单独的服务器进程来管理数据库。应用程序使用函数调用与数据库引擎交互，而不是通过将消息发送到单独的进程或线程。

SQLite 是嵌入式和无服务器而不是客户端/服务器 的事实是一个特性，而不是一个错误。

## 没有单独的 DATETIME 数据类型
SQLite 没有 DATETIME 数据类型。相反，日期和时间可以通过以下任何一种方式存储：

作为 ISO-8601 格式的文本字符串。示例：“2018-04-02 12:13:46”。
自 1970 年以来的整数秒数（也称为“unix 时间”）。
作为一个 REAL 值，它是分数 Julian day number。
SQLite的内置日期和时间函数可以理解上述所有格式的日期/时间，并且可以在它们之间自由转换。您使用哪种格式完全取决于您的应用程序。

https://sqlite.readdevdocs.com/lang_datefunc.html


## 准备好的语句对象
```c
typedef struct sqlite3_stmt sqlite3_stmt;
```
此对象的一个​​实例表示已编译成二进制形式并准备好进行执行的单个 SQL 语句。

将每个 SQL 语句视为一个单独的计算机程序。原始 SQL 文本是源代码。准备好的语句对象是编译后的目标代码。所有的SQL都必须先转换成prepared statement才能运行。

准备好的语句对象的生命周期通常是这样的：

1. 使用sqlite3_prepare_v2()创建准备好的语句对象。
1. 使用 sqlite3_bind_*() 接口将 值绑定到参数。
1. 通过调用sqlite3_step()一次或多次来运行 SQL。
1. 使用sqlite3_reset()重置准备好的语句，然后返回到步骤 2。执行此操作零次或多次。
1. 使用sqlite3_finalize()销毁对象。

## API
SQLite 有超过 225 个 API。但是，大多数 API 都是可选的并且非常专业，初学者可以忽略。核心 API 小巧、简单且易于学习。

***

```c
int sqlite3_open(
  const char *filename,   /* Database filename (UTF-8) */
  sqlite3 **ppDb          /* OUT: SQLite db handle */
);
```
此例程打开一个到 SQLite 数据库文件的连接并返回一个 数据库连接对象。这通常是应用程序进行的第一个 SQLite API 调用，并且是大多数其他 SQLite API 的先决条件。许多 SQLite 接口需要一个指向数据库连接对象的指针作为它们的第一个参数，并且可以被认为是数据库连接对象上的方法。该例程是数据库连接对象的构造函数。

如果数据库成功打开，则返回SQLITE_OK，否则返回错误代码。

***

```C
int sqlite3_prepare_v2(
  sqlite3 *db,            /* Database handle */
  const char *zSql,       /* SQL statement, UTF-8 encoded */
  int nByte,              /* Maximum length of zSql in bytes. */
  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
  const char **pzTail     /* OUT: Pointer to unused portion of zSql */
);
```
此例程将 SQL 文本转换为准备好的语句对象并返回指向该对象的指针。该接口需要一个由先前调用sqlite3_open()创建的数据库连接指针和一个包含要准备的 SQL 语句的文本字符串。该 API 实际上并不执行 SQL 语句。它只是准备用于执行的 SQL 语句。

将每个 SQL 语句视为一个小型计算机程序。sqlite3_prepare_v2()的目的是将该程序编译成目标代码。准备好的语句是目标代码。sqlite3_step()接口然后运行目标代码以获得结果。

如果 nByte 参数为负数，则读取 zSql 直到第一个零终止符。如果 nByte 为正数，则它是从 zSql 读取的字节数。如果 nByte 为零，则不会生成准备好的语句。

**参数化查询/预处理语句**  
在sqlite3_prepare_v2()及其变体的 SQL 语句文本输入中，文字可能会被匹配以下模板之一的参数替换：
- ？
- ？NNN
- :VVV
- @VVV
- $VVV
在上面的模板中，NNN 表示整数文字，VVV 表示字母数字标识符。这些参数的值（也称为“主机参数名称”或“SQL 参数”）可以使用sqlite3_bind_*()进行设置。

在 SQL 中，使用参数占位符，允许动态地将值插入到 SQL 语句中。使用sqlite3_prepare_v2函数将SQL语句编译成预处理语句。此时，数据库引擎会解析SQL语句，识别出占位符，并准备好执行计划。通过sqlite3_bind_*系列函数将具体的值绑定到预处理语句中的占位符。每个占位符的位置由索引指定，索引从1开始。

**为什么使用占位符？**
1. 防止 SQL 注入：避免直接将用户输入拼接到 SQL 语句中。
1. 提高性能：预处理语句可重复使用，减少数据库解析开销。
1. 类型安全：明确绑定数据类型（如整数、字符串）。

***

```c
int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                        void(*)(void*));
int sqlite3_bind_double(sqlite3_stmt*, int, double);
int sqlite3_bind_int(sqlite3_stmt*, int, int);
int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
int sqlite3_bind_null(sqlite3_stmt*, int);
int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                         void(*)(void*), unsigned char encoding);
int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));
int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
```
将值绑定到准备好的sql语句中的占位符中

***

```c
int sqlite3_step(sqlite3_stmt*);
```
在使用 sqlite3_prepare_v2()准备好语句后，可以调用此函数执行一次或多次。

当返回SQLITE_ROW时，说明当前有一行数据可用，可以通过sqlite3_column_*系列函数来获取各列的值，再次调用 sqlite3_step() 以检索下一行数据。当返回SQLITE_DONE时，说明所有数据已经处理完毕，循环结束。
>INSERT、UPDATE 或 DELETE语句执行一次step可运行完成，SELECT语句可能需要执行多次

***

```c
const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
double sqlite3_column_double(sqlite3_stmt*, int iCol);
int sqlite3_column_int(sqlite3_stmt*, int iCol);
sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
int sqlite3_column_type(sqlite3_stmt*, int iCol);
```
此例程从结果集的当前行返回单个列，用于由sqlite3_step()执行的准备好的语句。每次sqlite3_step()以新的结果集行停止时，可以多次调用此例程以查找该行中所有列的值。

这些例程返回有关查询当前结果行的单个列的信息。在每种情况下，第一个参数是指向正在执行的准备语句的指针（ 从sqlite3_prepare_v2()或其变体之一返回的sqlite3_stmt* ），第二个参数是应返回信息的列的索引. **结果集最左边的列的索引为 0**。结果中的列数可以使用 sqlite3_column_count()确定。

这些例程只能在最近调用 sqlite3_step()返回SQLITE_ROW并且随后既没有 调用 sqlite3_reset( )也没有调用sqlite3_finalize()时调用。

前六个接口（_blob、_double、_int、_int64、_text 和 _text16）均以特定数据格式返回结果列的值。如果结果列最初不是请求的格式（例如，如果查询返回一个整数但 sqlite3_column_text() 接口用于提取值）则执行自动类型转换。

***

```c
int sqlite3_finalize(sqlite3_stmt *pStmt);
```
销毁准备好的语句对象

此例程会破坏由先前调用sqlite3_prepare_v2()创建的准备好的语句。为了避免内存泄漏，必须使用对此例程的调用来销毁每个准备好的语句。

***

```c
int sqlite3_close(sqlite3*);
int sqlite3_close_v2(sqlite3*);
```
关闭数据库连接
sqlite3_close() 和 sqlite3_close_v2() 例程是sqlite3对象的析构函数。如果sqlite3对象被成功销毁并且所有相关资源都被释放，则调用 sqlite3_close() 和 sqlite3_close_v2() 返回SQLITE_OK 。

此例程关闭先前通过调用sqlite3_open()打开的数据库连接。所有与连接关联的准备好的语句都应该在关闭连接之前完成。

***
**一步查询执行接口**

```c
int sqlite3_exec(
  sqlite3*,                                  /* An open database */
  const char *sql,                           /* SQL to be evaluated */
  int (*callback)(void*,int,char**,char**),  /* Callback function */
  void *,                                    /* 1st argument to callback */
  char **errmsg                              /* Error msg written here */
);
```

sqlite3_exec() 接口是sqlite3_prepare_v2()、sqlite3_step()和sqlite3_finalize() 的便利包装器 ，它允许应用程序运行多个 SQL 语句而无需使用大量 C 代码。

sqlite3_exec() 接口在作为第一个参数传入的数据库连接的上下文中运行零个或多个 UTF-8 编码的、以分号分隔的 SQL 语句并传入其第二个参数。
如果 sqlite3_exec() 的第 3 个参数的回调函数不为 NULL，那么它会为来自执行 SQL 语句的每个结果行调用。
sqlite3_exec() 的第四个参数被传递到每个回调调用的第一个参数。如果指向 sqlite3_exec() 的回调指针为 NULL，则不会调用回调并且忽略结果行。

如果在执行传递给 sqlite3_exec() 的 SQL 语句时发生错误，则当前语句的执行将停止并跳过后续语句。**如果 sqlite3_exec() 的第 5 个参数不是 NULL，那么任何错误消息都会写入从sqlite3_malloc()获得的内存中，并通过第 5 个参数传回。为避免内存泄漏，应用程序应 在不再需要错误消息字符串后，对通过 sqlite3_exec() 的第 5 个参数返回的错误消息字符串调用sqlite3_free()** 。如果 sqlite3_exec() 的第 5 个参数不是 NULL 并且没有发生错误，则 sqlite3_exec() 在返回之前将其第 5 个参数中的指针设置为 NULL。


## Note

要运行 SQL 语句，应用程序遵循以下步骤：

1. 使用sqlite3_prepare()创建准备好的语句。
2. 通过调用sqlite3_step()一次或多次来执行准备好的语句。
3. 对于查询，通过在两次调用sqlite3_step ()之间调用 sqlite3_column() 来提取结果 。
4. 使用sqlite3_finalize()销毁准备好的语句。
上述内容是有效使用 SQLite 真正需要了解的全部内容。剩下的就是优化和细节。


允许应用程序预先准备多条 SQL 语句，并根据需要对其进行执行。对未完成的准备好的语句的数量没有任意限制 。一些应用程序在启动时多次调用sqlite3_prepare()以创建它们将永远需要的所有准备好的语句。其他应用程序保留最近使用的准备语句的缓存，然后在可用时 重用缓存中的准备语句。另一种方法是仅在循环内重用准备好的语句。


sqlite3_busy_timeout 是 SQLite 提供的一个关键函数，用于在多线程或多进程访问数据库时，优化并发控制，避免因数据库锁（SQLITE_BUSY 错误）导致的操作失败。

当 SQLite 数据库因并发访问被锁定时（例如一个写操作未完成，另一个操作试图访问），默认行为是立即返回 SQLITE_BUSY 错误。sqlite3_busy_timeout 的作用是 设置一个等待超时时间（毫秒），在超时时间内，SQLite 会不断重试操作，而非立即报错。
