---
title: "Zlog（C语言高性能日志库）"
description: 
date: 2025-02-06 10:00:00 +0800
categories: [Linux]
tags: [Linux]
pin: false

media_subpath: ""
#
# image:
#   path: 'assets/**/**.jpg'
#   alt: Here is the text under the image
---

Zlog 是一个 高性能、灵活的 C 语言日志库，支持 多线程、多进程、安全日志轮转、自定义格式，适用于高并发服务器、嵌入式系统、微服务等应用。

[zlog官方使用手册](https://hardysimpson.github.io/zlog/UsersGuide-CN.html)

## 自定义配置文件
```bash
[global]
#如果使用设置为true时，Zlog就会严格检查所用格式和规则，否则，忽略所用格式和规则。
strict init = true
buffer min = 1024
buffer max = 2048
#转档指定锁文件，用于保证多进程下日志安全转档，使用默认的配置文件为锁文件
# rotate lock file = /tmp/zlog.lock
#默认日志输出格式 2025-02-01 10:23:29.542658 INFO  : [31668:hello.c:41] hello, zlog
default format = "%d.%us %-6V: [%p:%F:%L] %m%n"
#日志访问权限,600 只允许当前用户访问
file perms = 600

[levels]
#自定义新的日志等级，范围[1,253]

[formats]
# simple = "%m%n"
# normal = "%d %m%n"
simple	= "%d.%us %-6V: %m%n"
normal	= "%d.%us %-6V: [%p:%F:%L] %m%n"

[rules]
#优先级从低到高 DEBUG INFO NOTICE WARN ERROR FATAL
#大于等于debug的优先级都能通过debug输出
# my_cat.ERROR    >stderr;
my_cat.*        >stdout;simple
my_cat.INFO     "/user/log/zlog_info.log", 5MB * 3 ~ "/user/log/zlog_info.#2s.log";simple
# my_cat.ERROR    "/user/log/zlog_error.log", 1MB * 3 ~ "/user/log/zlog_error_%d(%Y%m%d).#2s.log";simple
```

## 编译安装
```bash
$ tar -zxvf zlog-latest-stable.tar.gz
$ cd zlog-latest-stable/
$ make 
$ sudo make install
or
$ sudo make PREFIX=/usr/local/ install
```
PREFIX指明了安装的路径，安装完之后为了让你的程序能找到zlog动态库
```bash
$ sudo vi /etc/ld.so.conf
/usr/local/lib

$ sudo ldconfig
```
在你的程序运行之前，保证libzlog.so在系统的动态链接库加载器可以找到的目录下。

## 应用程序调用和链接zlog
应用程序使用zlog很简单，只要在C文件里面加一行`#include "zlog.h"`。

链接zlog需要pthread库，命令是：
```bash
$ cc -c -o app.o app.c -I/usr/local/include
  # -I[where zlog.h is put]

$ cc -o app app.o -L/usr/local/lib -lzlog -lpthread

  # -L[where libzlog.so is put]
```

## 分类(Category)、规则(Rule)和格式(Format)
zlog有3个重要的概念：分类(Category)、规则(Rule)和格式(Format)。

分类(Category)用于区分不同的输入。代码中的分类变量的名字是一个字符串，在一个程序里面可以通过获取不同的分类名的category用来后面输出不同分类的日志，用于不同的目的。

格式(Format)是用来描述输出日志的格式，比如是否有带有时间戳，是否包含文件位置信息等。

规则(Rule)则是把分类、级别、输出文件、格式组合起来，决定一条代码中的日志是否输出，输出到哪里，以什么格式输出。

所以，当程序执行下面的语句的时候
```c
zlog_category_t *c;
c = zlog_get_category("my_cat");
zlog_info(c, "hello, zlog");
```
zlog会找到c的名字是"my_cat"，对应的配置文件中的规则是
```bash
[rules]
my_cat.DEBUG    >stdout; simple
```
然后库会检查，目前这条日志的级别是否符合规则中的级别来决定是否输出。因为INFO>=DEBUG，所以这条日志会被输出。并且根据这条规则，会被输出到stdout（标准输出） ，输出的格式是simple，在配置文件中定义是
```bash
[formats]
simple = "%m%n" 
```
最后在屏幕上打印
```
hello, zlog
```
这就是整个过程。用户要做就是写自己的信息。日志往哪里输出，以什么格式输出，都是库和配置文件来完成的。

## 规则举例
如果在zlog的配置文件中有这么2行规则：
```bash
[rules]
my_cat.DEBUG     >stdout; simple
my_cat.INFO      >stdout;
```
代码是：
```c
zlog_info(c, "hello, zlog");
```
那么，一行代码会产生两行输出：
```
hello, zlog
2012-05-29 10:41:36 INFO [11288:test_hello.c:41] hello, zlog
```
现在一个代码中的分类对应配置文件中的两条规则。继续看下一个例子：
```bash
[rules]
my_cat.WARN     "/var/log/aa.log"
my_cat.DEBUG    "/var/log/bb.log"
```
代码是：
```c
zlog_info(c, "info, zlog");
zlog_debug(c, "debug, zlog");
```
最后，在aa.log中只有一条日志
```
2012-05-29 10:41:36 INFO [11288:test_hello.c:41] info, zlog
```
但在bb.log里面有两条
```
2012-05-29 10:41:36 INFO [11288:test_hello.c:41] info, zlog
2012-05-29 10:41:36 DEBUG [11288:test_hello.c:42] debug, zlog
```

**在zlog里面，一个分类可以对应多个规则，每个规则有自己的级别、输出和格式。这就让用户能按照需求过滤、多渠道输出自己的所有日志。**

## 配置文件
大部分的zlog的行为取决于配置文件：把日志打到哪里去，用什么格式，怎么转档。
```bash
# comments

[global]
strict init = true
buffer min = 1024
buffer max = 2MB
rotate lock file = /tmp/zlog.lock
default format = "%d.%us %-6V (%c:%F:%L) - %m%n"
file perms = 600

[levels]
TRACE = 10
CRIT = 130, LOG_CRIT

[formats]
simple = "%m%n"
normal = "%d %m%n"

[rules]
default.*               >stdout; simple
*.*                     "%12.2E(HOME)/log/%c.log", 1MB*12; simple
my_.INFO                >stderr;
my_cat.!ERROR           "/var/log/aa.log"
my_dog.=DEBUG           >syslog, LOG_LOCAL0; simple
my_mice.*               $user_define;
```
### 全局参数
全局参数以[global]开头。[]代表一个节的开始，四个小节的顺序不能变，依次为global-levels-formats-rules。这一节可以忽略不写。

- strict init
>如果"strict init"是true，zlog_init()将会严格检查所有的格式和规则，任何错误都会导致zlog_init() 失败并且返回-1。当"strict init"是false的时候，zlog_init()会忽略错误的格式和规则。
- reload conf period  
>这个选项让zlog能在一段时间间隔后自动重载配置文件。重载的间隔以每进程写日志的次数来定义。当写日志次数到了一定值后，内部将会调用zlog_reload()进行重载。
- buffer min
- buffer max
>zlog在堆上为每个线程申请缓存。"buffer min"是单个缓存的最小值，zlog_init()的时候申请这个长度的内存。写日志的时候，如果单条日志长度大于缓存，缓存会自动扩充，直到到"buffer max"。 单条日志再长超过"buffer max"就会被截断。如果 "buffer max" 是 0，意味着不限制缓存，每次扩充为原先的2倍，直到这个进程用完所有内存为止。缓存大小可以加上 KB, MB 或 GB这些单位。默认来说"buffer min"是 1K ， "buffer max" 是2MB。
- rotate lock file
>这个选项指定了一个锁文件，用来保证多进程情况下日志安全转档。  
>默认来说，rotate lock file = self。在这种情况下，zlog不会创建任何锁文件，用配置文件作为锁文件。
- default format
>这个参数是缺省的日志格式，默认值为：`"%d %V [%p:%F:%L] %m%n"`  
>这种格式产生的输出类似这样：`2012-02-14 17:03:12 INFO [3758:test_hello.c:39] hello, zlog`
- file perms
>这个指定了创建日志文件的缺省访问权限。必须注意的是最后的产生的日志文件的权限为"file perms"& ~umask。默认为600，只允许当前用户读写。
- fsync period
>在每条规则写了一定次数的日志到文件后，zlog会调用fsync(3)来让操作系统马上把数据写到硬盘。

### 日志等级自定义
这一节以[levels]开始。用于定义用户自己的日志等级，建议和用户自定义的日志记录宏一起使用。这一节可以忽略不写。语法为：
```bash
(level string) = (level int), (syslog level, optional)
```
(level int)必须在[1,253]这个范围内，越大越重要。(syslog level)是可选的，如果不设默认为LOG_DEBUG。

### 格式(Formats)
这一节以[formats]开始。用来定义日志的格式。语法为：

(name) = "(actual formats)"
很好理解，(name)被后面的规则使用。(name)必须由数字和字母组成，下划线"_"也算字母。(actual format)前后需要有双引号。 (actual formats)可以由转换字符组成

#### 转换字符

| 字符 | 效果 | 例子 |
|--|--|--|
| %c  | 分类名 | aa_bb |
| %d  | 打日志的时间 | 2012-02-14 17:03:12 |
| %ms | 毫秒，3位数字字符串 | 013 |
| %us | 微秒，6位数字字符串 | 002323 |
| %F  | 源代码文件名，来源于__FILE__宏。 | /home/zlog/src/test/test_hello.c |
| %f  | 源代码文件名，输出$F最后一个’/’后面的部分 | test_hello.c |
| %L  | 源代码行数，来源于__LINE__宏 | 135 |
| %m  | 用户日志，用户从zlog函数输入的日志 | hello, zlog |
| %n  | 换行符 | \n |
| %p  | 进程ID，来源于getpid() | 2134 |
| %U  | 调用函数名，来自于__func__(C99)或者__FUNCTION__(gcc)，如果编译器支持的话 | main |
| %V  | 日志级别，大写 | INFO |
| %v  | 日志级别，小写 | info |
| %t  | 16进制表示的线程ID，来源于pthread_self() "0x%x",(unsigned int) pthread_t | INFO |
| %T  | 相当于%t,不过是以长整型表示的"%lu", (unsigned long) pthread_t | info |

#### 宽度修饰符
控制最小字段宽度、最大字段宽度和左右对齐。当然这要付出一定的性能代价。

可选的宽度修饰符放在百分号和转换字符之间。

第一个可选的宽度修饰符是左对齐标识，减号(-)。然后是可选的最小字段宽度，这是一个十进制数字常量，表示最少有几个字符会被输出。如果数据本来没有那么多字符，将会填充空格（左对齐或者右对齐）直到最小字段宽度为止。默认是填充在左边也就是右对齐。当然你也可以使用左对齐标志，指定为填充在右边来左对齐。填充字符为空格(space)。如果数据的宽度超过最小字段宽度，则按照数据的宽度输出，永远不会截断数据。

这种行为可以用最大字段宽度来改变。最大字段宽度是放在一个句点号(.)后面的十进制数字常量。如果数据的宽度超过了最大字段宽度，则尾部多余的字符（超过最大字段宽度的部分）将会被截去。 最大字段宽度是8，数据的宽度是10，则最后两个字符会被丢弃。这种行为和C的printf是一样的，把后面的部分截断。

| 宽度修饰符 | 左对齐 | 最小字段宽度 | 最大字段宽度 | 附注 |
|--|--|--|--|--|
| %20c | 否 | 20 | 无 | 左补充空格，如果分类名小于20个字符长 |
| %-20c | 是 | 20 | 无 | 右补充空格，如果分类名小于20个字符长 |
| %.30c | 无 | 无 | 30 | 如果分类名大于30个字符长，取前30个字符，去掉后面的 |
| %20.30c | 否 | 20 | 30 | 如果分类名小于20个字符长，左补充空格。如果在20-30之间，按照原样输出。如果大于30个字符长，取前30个字符，去掉后面的|
| %-20.30c | 是 | 20 | 30 | 如果分类名小于20个字符长，右补充空格。如果在20-30之间，按照原样输出。如果大于30个字符长，取前30个字符，去掉后面的 |

### 规则(Rules)
这一节以[rules]开头。这个描述了日志是怎么被过滤、格式化以及被输出的。
```
(category).(level)    (output), (options, optional); (format name, optional)
```
#### 级别匹配
zlog有6个默认的级别："DEBUG", "INFO", "NOTICE", "WARN", "ERROR"和"FATAL"。就像其他的日志函数库那样， aa.DEBUG意味着任何大于等于DEBUG级别的日志会被输出。

| 表达式 | 含义 |
|--|--|
| * | 所有等级 |
| aa.debug  | 代码内等级>=debug |
| aa.=debug | 代码内等级==debug |
| aa.!debug | 代码内等级!=debug |

#### 分类匹配
分类必须由数字和字母组成，下划线"_"也算字母。

|总结 | 配置文件规则分类 | 匹配的代码分类 | 不匹配的代码分类 |
|--|--|--|--|
| *匹配所有 | *.* | aa, aa_bb, aa_cc, xx, yy  |  |
| 以_结尾的分类匹配本级及下级分类 | aa_.* | aa, aa_bb, aa_cc, aa_bb_cc | xx, yy |
| 不以_结尾的精确匹配分类名 | aa.* | aa | aa_bb, aa_cc, aa_bb_cc |
| !匹配那些没有找到规则的分类 | !.* |  |  |

#### 输出动作
1. 标准输出	>stdout

2. 标准错误输出	>stderr

3. 文件	"文件路径"
   - 文件路径  
   可以是相对路径或者绝对路径，被双引号""包含。转换格式串可以用在文件路径上。例如文件路径是 "%c_out.log"，每个分类一个日志。

   zlog的文件功能极为强大，例如
   1. 输出到命名管道(FIFO)，必须在调用前由mkfifo(1)创建  
   `*.*    "/tmp/pipefile"`
   2. 输出到NULL，也就是不输出  
   `*.*     "/dev/null"`
   3. 在任何情况下输出到终端  
   `*.*     "/dev/tty"`
   4. 每线程一个日志，在程序运行的目录下  
   `*.*     "%T.log"`
   5. 输出到有进程号区分的日志，每天，在$HOME/log目录，每1GB转档一次，保持5个日志文件  
   `*.*     "%E(HOME)/log/aa.%p.%d(%F).log",1GB * 5`
   6. aa_及下级分类，每个分类一个日志  
   `aa_.*      "/var/log/%c.log"`
   
   - 文件转档  
   控制文件的大小和个数。zlog根据这个字段来转档，当日志文件太大的时候。例如 `"%out.log", 1M * 3 ~ "%out.log.#r"`

## 文件转档
1. 按固定时间段来切分日志。
在zlog里面，这种需求不需要用日志转档功能来完成，简单的在日志文件名里面设置时间日期字符串就能解决问题：`*.*  "aa.%d(%F).log"`

2. 按照日志大小切分
最简单的zlog的转档配置为`*.*     "aa.log", 10MB`  
这个配置是Rolling的情况，每次aa.log超过10MB的时候，会做这样的重命名  
```
aa.log.2 -> aa.log.3
aa.log.1 -> aa.log.2
aa.log.0 -> aa.log.1
aa.log -> aa.log.0
```
上面的配置可以写的更加罗嗦一点  
`*.*     "aa.log", 10MB * 0 ~ "aa.log.#r"`  
逗号后第一个参数表示文件达到多大后开始进行转档。  
第二个参数表示保留多少个存档文件（0代表不删除任何存档文件）。  
第三个参数表示转档的文件名，其中#r表示存档文件的序号，r是rolling的缩写。还可以放#s，是sequence的缩写。转档文件名必须包含#r或者#s。

3. 按照日志大小切分，但同时加上时间标签
```
aa.log 
aa.log-20070305.00.log 
aa.log-20070501.00.log 
aa.log-20070501.01.log
aa.log-20071008.00.log
```
这种情况适合于程序本身的日志一般不是很受关注，但是又在某一天想要找出来看的情况。当然，在这种情况下，万一在20070501这一天日志的量超过了指定值，例如100MB，就又要退回到第二种状态，在文件名中加后缀。

zlog对应的配置是
`*.*     "aa.log", 100MB ~ "aa-%d(%Y%m%d).#2s.log"`
每到100MB的时候转档，转档文件名也支持转换字符，可以把转档当时的时间串作为转档文件名的一部分。#2s的意思是序号的长度最少为2位，从00开始编号，Sequence转档。这是zlog对转档最复杂的支持了！

## zlog接口(API)

### 初始化和清理
```C
int zlog_init(const char *confpath);
int zlog_reload(const char *confpath);

void zlog_fini(void);
```
### 分类(Category)操作
```C
typedef struct zlog_category_s zlog_category_t;
zlog_category_t *zlog_get_category(const char *cname);
```
### 写日志函数及宏
```C
zlog_fatal(cat, format, ...)
zlog_error(cat, format, ...)
zlog_warn(cat, format, ...)
zlog_notice(cat, format, ...)
zlog_info(cat, format, ...)
zlog_debug(cat, format, ...)
```
### dzlog接口
dzlog是忽略分类(zlog_category_t)的一组简单zlog接口。它采用内置的一个默认分类，这个分类置于锁的保护下。这些接口也是线程安全的。忽略了分类，意味着用户不需要操心创建、存储、传输zlog_category_t类型的变量。

dzlog_init()和zlog_init()一样做初始化，就是多需要一个默认分类名cname的参数。zlog_reload()、 zlog_fini() 可以和以前一样使用，用来刷新配置，或者清理。

dzlog_set_category()是用来改变默认分类用的。上一个分类会被替换成新的。同样不用担心内存释放的问题，zlog_fini()最后会清理。
```C
dzlog_fatal(format, ...)
dzlog_error(format, ...)
dzlog_warn(format, ...)
dzlog_notice(format, ...)
dzlog_info(format, ...)
dzlog_debug(format, ...)
```

### notice
zlog 提供了两类接口，分别是 zlog_xxx 和 dzlog_xxx 接口。其中 dzlog 接口是忽略分类（zlog_category_t）的一组简单的 zlog 接口，它采用内置的一个默认分类，这个分类置于锁的保护下。
>这里的 xxx 表示日志级别，在 zlog 日志库中，一共有 6 个默认的级别，分别是 DEBUG、INFO、NOTICE、WARN、ERROR 和 FATAL。

在使用 zlog 或 dzlog 接口之前，需要先调用 zlog_init() 或 dzlog_init() 进行初始化。
如果使用 zlog_init() 初始化，还需要调用 zlog_get_category() 接口设置分类名称
